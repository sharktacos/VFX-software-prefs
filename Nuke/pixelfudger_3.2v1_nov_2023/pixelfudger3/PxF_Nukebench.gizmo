
NoOp {
 name PxF_Nukebench
 help "Measure the speed of different parts of your computer: CPU, GPU, Disk Read/Write.\n\nYou can share your results and compare your machine with others in the community using the links provided at the bottom."
 onCreate "global community\n\ncommunity = False\n\n"
 knobChanged "tn = nuke.thisNode()\ntk = nuke.thisKnob()\n\n\n\n#RESET POSITION OF FILE TYPE CHOOSER WHEN USER CLEARS FILE TYPES\nif tk.name() == 'file_type_list':                     #If user edit filetype list by hand...\n  if tk.value() == '':                                #... if filetype list is empty...\n    tn\['file_type'].setValue('File types')            #... Toggle file type selector to first position\n    tn\['fileTypeShortcuts'].setValue('Shortcuts')     #... Toggle file type shortcuts to first position\n\n\n#ADD SELECTED RESOLUTION TO LIST WHEN USER TOUCHES RESOLUTION CHOOSER\nif tk.name() == 'format':                             #If user touched resolution selector \n    format = tn\['format'].value().name()              #Get the resolution's name\n    rezlist = tn\['rez_list'].value()                  #Get the current resolution list\n    if rezlist:                                       #If list is not empty...\n        rezlist = rezlist.split(',')                  #... convert string to list\n    else:                                             #If list is empty...\n        rezlist = \[]                                  #... create an empty list\n    rezlist.append(format)                            #Append selected format to list\n    rezlist = \",\".join(rezlist)                       #Convert list to string\n    tn\['rez_list'].setValue(rezlist)                  #Write string to rez_list knob\n\n\n\n\n#ADD SELECTED FILE TYPE TO LIST WHEN USER TOUCHES FILE TYPE CHOOSER\nif tk.name() == 'file_type':                                #If user touched file type selector\n    filetype = tn\['file_type'].value()                      #Get the file type\n    filetype = filetype.split('/')\[1]                       #Get only the part after the '/'\n    filetype = filetype.replace(' ', '_').replace('%', '')  #Replace ' ' with '_', get rid of %\n    ftlist = tn\['file_type_list'].value()                   #Get the current file type list\n    if ftlist == '':                                        #If the list is empty...\n      ftlist = filetype                                     #Put the selected rez in the rezlist\n    else:                                                   #If the list is not empty...\n      ftlist = ftlist + ',' + filetype                      #Append the selected list to the rezlist\n    tn\['file_type_list'].setValue(ftlist)                   #Write the rezlist to the file_type_list knob\n\n\n\n#ENABLE/DISABLE KNOBS ACCORDING TO USER SELECTIONS TO MAKE UI EASIER TO NAVIGATE\nif tk.name() == 'runWriteTest':                      #If user touched write test checkbox\n  if tk.value() == True:                             #If write test is 'on'...\n    tn\['noisyWrite'].setEnabled(True)                #Enable the noisyWrite checkbox\n  else:                                              #If the write test is off...\n    tn\['noisyWrite'].setEnabled(False)               #Disable the noisyWrite checkbox\n    \nif tk.name() == 'runCPU':                            #If user touched CPU test checkbox\n  if tk.value() == True:                             #If CPU test is 'on'...\n    tn\['useNew3D'].setEnabled(True)                  #Enable the useNew3D checkbox\n  else:                                              ##If CPU test is 'off'...\n    tn\['useNew3D'].setEnabled(False)                 #Enable the useNew3D checkbox\n    \nif tk.name() == 'runGPUZdefocus':\n  if tk.value() == True:\n    tn\['useCPUZDefocus'].setEnabled(True)\n  else:\n    tn\['useCPUZDefocus'].setEnabled(False)\n    \nif tk.name() == 'runGPUInference':\n  if tk.value() == True:\n    tn\['useCPUInference'].setEnabled(True)\n  else:\n    tn\['useCPUInference'].setEnabled(False)\n\n\n#APPEND FILE TYPES TO THE FILETYPE LIST ACCORDING TO WHICH FILE TYPE SHORTCUT CHOOSER\nif tk.name() == 'fileTypeShortcuts':             #If user touched the shortcut chooser...\n  sct = tk.value()                               #Get the selected shortcut\n  ftlist = tn\['file_type_list'].value()          #Get the current file type list\n  if not ftlist == '':                           #If the file type list is not empty...\n    ftlist += ','                                #Add a comma at the end\n                                                 #Add the appropriate formats depending on user selection...\n  if sct == \"32/32 float lossless\":\n    ftlist += 'EXR32_none,EXR32_Zip_1_scanline,EXR32_Zip_16_scanline,EXR32_PIZ_32_scanlines,EXR32_RLE,TIFF_32_bit,TIFF_32_bit_PackBits,TIFF_32_bit_LZW,TIFF_32_bit_Deflate'\n  if sct == \"32/32 float lossy\":\n    ftlist += 'EXR32_B44,EXR32_B44A,EXR32_DWAA_200,EXR32_DWAA_50,EXR32_DWAB_200,EXR32_DWAB_50'\n  if sct == \"16/16 float lossless\":\n    ftlist += 'EXR16_none,EXR16_Zip_1_scanline,EXR16_Zip_16_scanline,EXR16_PIZ_32_scanlines,EXR16_RLE,HDR'\n  if sct == \"16/16 float lossy\":\n    ftlist += 'EXR16_B44,EXR16_B44A,EXR16_DWAA_200,EXR16_DWAA_50,EXR16_DWAB_200,EXR16_DWAB_50'\n  if sct == \"16/16 integer lossless\":\n    ftlist += 'DPX_16_bit_BE,DPX_16_bit_LE,PNG_16_bit,SGI_16_bit,TIFF_16_bit,TIFF_16_bit_PackBits,TIFF_16_bit_LZW,TIFF_16_bit_Deflate'\n  if sct == \"16/16 integer lossy\":\n    ftlist += ''\n  if sct == \"12/12 integer lossless\":\n    ftlist += 'DPX_12_bit_BE,DPX_12_bit_LE'\n  if sct == \"12/12 integer lossy\":\n    ftlist += 'MOV_ProRes_4444_12_bit,MOV_ProRes_4444_XQ_12_bit,MXF_444_12_bit,MXF_HQX_12_bit'\n  if sct == \"10/10 integer lossless\":\n    ftlist += 'DPX_10_bit_BE,DPX_10_bit_LE,CINEON'\n  if sct == \"10/10 integer lossy\":\n    ftlist += 'MOV_ProRes_Proxy_10_bit,MOV_ProRes_LT_422_10_bit,MOV_ProRes_422_10_bit,MOV_ProRes_422_HQ_10_bit'\n  if sct == \"8/8 integer lossless\":\n    ftlist += 'DPX_8_bit_BE,DPX_8_bit_LE,SOFTIMAGE_PIC,PNG_8_bit,SGI_8_bit,TARGA,TIFF_8_bit,TIFF_8_bit_PackBits,TIFF_8_bit_LZW,TIFF_8_bit_Deflate'\n  if sct == \"8/8 integer lossy\":\n    ftlist += 'JPEG_95,JPEG_75,JPEG_50,MXF_HQ_8_bit,MXF_SQ_8_bit,MXF_LB_8_bit'\n  tn\['file_type_list'].setValue(ftlist)        #Write to file_type_list knob\n  \n"
 updateUI "import os\n\ntn = nuke.thisNode()\n\nncCheck = False\nif nuke.env\['nc'] or nuke.env\['indie']:\n  ncCheck = True\n\n\ndisableList = \[\"runReadTest\", \"runReadToViewer\", \"format\", \"rez_list\", \"file_type\", \"file_type_list\", \"catFile\", \"inferenceScale\", \"READ_LIST\", \"pickReads\", \"clearRezList\", \"clearFileTypeList\", \"clearReadList\", \"fileTypeShortcuts\", \"userWarning\"]\n\nturnOffList = \[ \"runCPU\", \"useNew3D\", \"runGPUZdefocus\", \"useCPUZDefocus\", \"runGPUInference\", \"useCPUInference\", \"runWriteTest\", \"noisyWrite\", \"runReadTest\", \"runReadToViewer\"]\n\ncondDisableDict = \{\"runCPU\":\"useNew3D\", \"runGPUZdefocus\":\"useCPUZDefocus\", \"runGPUInference\":\"useCPUInference\", \"runWriteTest\":\"noisyWrite\"\}\n\nfor kb in disableList:\n  if ncCheck:\n    tn\[kb].setEnabled(False)\n    tn\['nc_warning'].setVisible(True)\n  else:\n    tn\[kb].setEnabled(True)\n    tn\['nc_warning'].setVisible(False)\n\nfor kb in turnOffList:\n  if ncCheck:\n    tn\[kb].setValue(False)\n    \nfor kb in condDisableDict.keys():\n  if ncCheck:\n    tn\[kb].setEnabled(False)\n    tn\[condDisableDict\[kb]].setEnabled(False)\n  else:\n    tn\[kb].setEnabled(True)\n    if tn\[kb].value() == True:\n      tn\[condDisableDict\[kb]].setEnabled(True)\n\ncp = nuke.toNode('preferences')\['DiskCachePath'].value()   #CachePath... nuke disk cache location\nif cp == '\[getenv NUKE_TEMP_DIR]':                         #If cachepath is default...\n  cp = os.environ\['NUKE_TEMP_DIR']                         #Get value of NUKE_TEMP_DIR env variable instead\ntn\['cachepath'].setValue(cp)\n\nif nuke.NUKE_VERSION_MAJOR >= 13 and ncCheck == False:\n  tn\['runGPUInference'].setEnabled(True)\nelse:\n  tn\['runGPUInference'].setEnabled(False)\n  tn\['runGPUInference'].setValue(False)\n  \nif nuke.NUKE_VERSION_MAJOR >= 14 and ncCheck == False:\n  if tn\['runCPU'].value() == True:\n      tn\['useNew3D'].setEnabled(True)\nelse:\n  tn\['useNew3D'].setEnabled(False)\n  tn\['useNew3D'].setValue(False)"
 tile_color 0x733520ff
 addUserKnob {20 PxF_Nukebench}
 addUserKnob {2 base_path l "temp directory" t "Temp directory for Write IO test files.\n\nUse a directory on a fast local drive (i.e. SSD) to test your disk speed or on a remote server to test your network speed.\n\nDepending on the resolution, file format and number of frames, you may need a lot of disk space to complete the Write IO test."}
 addUserKnob {1 cachepath l "cache directory" t "Make sure your Nuke cache is on a fast local drive (i.e. SSD or fast RAID).\n\nYou can adjust your cache path in Nuke's preferences.\n\nPreferences -> Performance -> Caching -> temp directory" +DISABLED}
 cachepath C:/Users/Xavier/AppData/Local/Temp/nuke
 addUserKnob {22 RUN_NC l "Run Simple Benchmarks..." T "import time\nimport psutil\nimport platform\nimport os\nfrom PySide2 import QtWidgets\n\n\ndef runNCtests():\n  \n  tn            = nuke.thisNode()\n  tnName        = tn.name()\n  \n  #INIT UTILITY FUNCTIONS\n  tn\['INIT_FUNCTIONS'].execute()\n\n\n  cpuWt         = nuke.toNode('SCANLINE_Classic_HD_1080')\n  gpuWt         = nuke.toNode('ZDEFOCUS_HD_1080')\n  exrWt32       = nuke.toNode('WRITE_HD_1080_NS_EXR32_none')\n  exrWt16z      = nuke.toNode('WRITE_HD_1080_NS_EXR16_Zip_1_scanline')\n  exrWts        = \[exrWt32 , exrWt16z]\n  exrNull32     = nuke.toNode('NULL_HD_1080_NS_EXR32_none')\n  exrNull16z    = nuke.toNode('NULL_HD_1080_NS_EXR16_Zip_1_scanline')\n  exrNullWts    = \[exrNull32 , exrNull16z]\n  writes        = \[cpuWt, gpuWt, exrWt32, exrWt16z, exrNull32, exrNull16z]\n  #ncCheck       = nuke.env\['nc'] or nuke.env\['indie']\n  bp            = tn\['base_path'].value()\n  sta           = 1\n  end           = int(tn\['last'].value())\n  ioEnd         = int(tn\['ioLast'].value())\n  sizeExr16     = 23.7                                                             #Size of a EXR uncompressed frame\n  sizeExr16Zip  = 6.1                                                             #Size of a EXR zip frame\n  spaceReq      = round(((ioEnd * sizeExr16) + (ioEnd * sizeExr16Zip)) / 1024 , 1) #Disk space required for test in GB\n  nukeVer       = nukebenchGetNukeVer()                                          #Current Nuke version\n  host          = platform.node()                                                #Hostname\n  gpu           = nuke.toNode('preferences')\['selectedGPUDeviceIndex'].value()   #GPU name\n  cpuCores      = psutil.cpu_count(logical=False)                                #Number of CPU cores\n  cpuThreads    = psutil.cpu_count(logical=True)                                 #Number of CPU threads\n  ram           = round(psutil.virtual_memory().total / (1023**3),0)             #Amount of RAM in GB\n  cpuFreq       = nukebenchGetCPUFreq()\n  \n  #Warning message to user\n  msg = 'Are you sure you want to run the Simple Benchmarks?'\n  msg += '\\n'\n  msg += '\\n-This may take a few minutes.'\n  msg += '\\n\\n-You need at least ' + str(spaceReq) + 'GB of disk space for your \"temp\" directory.'\n  msg += '\\n\\n-Your Nuke cache will be cleared.'\n  msg += '\\n'\n  msg += '\\nDo you wish to continue?'\n  \n  #Ask user if we can continue\n  userAgree = nuke.ask(msg)\n  if not userAgree:\n    return\n  \n  \n  \n  \n  nukebenchSetStatus('Starting Simple Benchmarks...', '', 'orange')\n  \n  #Clear the report\n  tn\['COM_REPORT'].setValue('')\n  comReport = ''\n  \n  #CHECK IF TEMP PATH IS EMPTY\n  if bp == '':\n    if nuke.ask('No temp directory specified. This directory is used to write temporary files. Do you want to choose one now?'):\n      bp = nuke.getFilename('Pick a temp directory.', '')\n      if bp == None:\n        return\n      else:\n        tn\['base_path'].setValue(bp)\n    else:\n      return\n      \n  #CHECK IF TEMP PATH IS REALLY A DIRECTORY.\n  if not os.path.isdir(bp):\n      nuke.message('Please specify valid temp files directory.\\n(' + bp + ') is not a directory.' )\n      return\n  \n  # Add a leading '/' to temp file directory if missing\n  if not (bp\[-1] == '/'):\n      bp += '/'\n      tn\['base_path'].setValue(bp)\n  \n      \n  #Make sure 'end' values are at least 1 frame\n  if end < 1:\n    end = 1\n  \n  if ioEnd < 1:\n    end = 1 \n  \n  #CHECK IF WRITE NODES EXIST\n  missingWrite = 0\n  idx = 0\n  for wt in writes:\n    if wt == None:\n      missingWrite = 1\n\n  #IF WRITE NODES ARE MISSING...\n  #BUILD THE NODE GRAPH WITH SCRIPT STORED IN HIDDEN 'node_graph' KNOB.\n  #VERY FRAGILE... BETTER SOLUTION?\n  \n  if missingWrite:\n    tn\['eject_nodes'].execute()\n    cpuWt         = nuke.toNode('SCANLINE_Classic_HD_1080')\n    gpuWt         = nuke.toNode('ZDEFOCUS_HD_1080')\n    exrWt32       = nuke.toNode('WRITE_HD_1080_NS_EXR32_none')\n    exrWt16z      = nuke.toNode('WRITE_HD_1080_NS_EXR16_Zip_1_scanline')\n    exrWts        = \[exrWt32 , exrWt16z]\n    exrNull32     = nuke.toNode('NULL_HD_1080_NS_EXR32_none')\n    exrNull16z    = nuke.toNode('NULL_HD_1080_NS_EXR16_Zip_1_scanline')\n    exrNullWts    = \[exrNull32 , exrNull16z]\n\n  \n  \n  #INCLUDE HARDWARE INFO\n  nukebenchSetStatus('Getting Hardware Info...', '', 'orange') #Update status knob\n  comReport += \"NUKE: \" + nukeVer                                          #Build the simple report...\n  comReport += \"\\nOS: \" + nukebenchGetPrettyOSName()\n  comReport += \"\\nRAM: \" + str(int(ram))\n  comReport += \"\\nGPU: \" + gpu\n  comReport += \"\\nCPU: \" + nukebenchGetPrettyCPUName()\['name']\n  comReport += \"\\nCORES: \" + str(cpuCores)\n  comReport += \"\\nTHREADS: \" + str(cpuThreads)\n  comReport += \"\\nFREQ GHz: \" + str(cpuFreq)\n  tn\['COM_REPORT'].setValue(comReport)                                    #Write result to COM_REPORT knob\n  nukebenchSetStatus('Ready', '', 'green')\n  \n  \n  #RUN CPU TEST\n  nukebenchClearCaches()\n  nukebenchSetStatus('Running CPU ScanlineRender test...', cpuWt.name(), 'orange') #Update status knob\n  clockStart = time.time()                                   #Save start time in variable\n  nuke.render(cpuWt,sta,end)                                 #Render Write node from first to last frame\n  clockStop = time.time()                                    #Save end time in variable\n  clockDur = (clockStop-clockStart)                          #Duration of the render in seconds\n  clipLength = (end-sta+1)                                   #Clip length in frames\n  fps = clipLength/clockDur                                  #Average frames per second\n  comReport += '\\nSCANLINE fps: ' + str(round(fps,3))      #Add line to simple report\n  tn\['COM_REPORT'].setValue(comReport)                     #Write report to COM_REPORT knob\n  nukebenchSetStatus('Ready', '', 'green')\n  \n  #RUN GPU TEST\n  nukebenchClearCaches()\n  nukebenchSetStatus('Running GPU ZDefocus test...', gpuWt.name(), 'orange') #Update status knob\n  clockStart = time.time()                                   #Save start time in variable\n  nuke.render(gpuWt,sta,end)                                 #Render Write node from first to last frame\n  clockStop = time.time()                                    #Save end time in variable\n  clockDur = (clockStop-clockStart)                          #Duration of the render in seconds\n  clipLength = (end-sta+1)                                   #Clip length in frames\n  fps = clipLength/clockDur                                  #Average frames per second\n  comReport += '\\nZDEFOCUS fps: ' + str(round(fps,3))        #Add line to simple report\n  tn\['COM_REPORT'].setValue(comReport)                       #Write report to COM_REPORT knob\n  nukebenchSetStatus('Ready', '', 'green')\n  \n  \n  #RUN WRITE TESTS\n  \n  for wt in exrWts:\n    nukebenchClearCaches()\n    nukebenchSetStatus('Running IO Write test...', wt.name(),'orange')          #Update status knob\n    clockStart = time.time()                                                    #Start time\n    nuke.render(wt,sta,ioEnd)                                                     #Render Write node from first to last frame\n    clockStop = time.time()                                                     #End time\n    clockDur = (clockStop-clockStart)                                           #Duration of the render in seconds\n    clipLength = (ioEnd-sta+1)                                                    #Clip length in frames\n    realPath = wt\['file'].value().replace(\"\[value \" + tnName + \".base_path]\", bp)\n    #realPath = wt\['file'].evaluate()\n    clipSize = nukebenchGetClipSize(realPath,sta,ioEnd) / 1024 / 1024   #Clip size in MBytes\n    frameSize = clipSize / clipLength                                           #Average frame size in MBytes\n    dataSpeed = clipSize / clockDur                                             #Average throughput in MB/s\n    fps = clipLength/clockDur                                                   #Average frames per second\n    comReport += '\\n' + wt.name() + ' MB/s: ' + str(round(dataSpeed,2))       #Add relevant info to report\n    comReport += '\\n' + wt.name() + ' fps: ' + str(round(fps,3))\n    tn\['COM_REPORT'].setValue(comReport)                                      #Write to COM_REPORT knob\n    nukebenchSetStatus('Ready', '', 'green')\n    \n  #RUN READ TESTS\n  for wt in exrNullWts:   \n    nukebenchClearCaches()                                     #For each Read name in Read List...\n    rdName = wt.name().replace('NULL','READ')\n    nukebenchSetStatus('Running IO Read test...', rdName, 'orange') #Update status knob\n    clockStart = time.time()                                   #Save start time in variable\n    nuke.render(wt,sta,ioEnd)                                    #Render Write node from first to last frame\n    clockStop = time.time()                                    #Save end time in variable\n    clockDur = (clockStop-clockStart)                          #Duration of the render in seconds\n    clipLength = (ioEnd-sta+1)                                   #Clip length in frames\n    realPath = wt\['file'].value().replace(\"\[value \" + tnName + \".base_path]\", bp).replace('.null', '.exr')\n    #realPath = wt\['file'].evaluate()\n    clipSize = nukebenchGetClipSize(realPath,sta,ioEnd) / 1024 / 1024  #Clip size in MBytes\n    frameSize = clipSize / clipLength                          #Average frame size in MBytes\n    dataSpeed = clipSize / clockDur                            #Average throughput in MB/s\n    fps = clipLength/clockDur                                  #Average frames per second\n    comReport += '\\n' + rdName + ' MB/s: ' + str(round(dataSpeed,2)) #Add speed to report\n    comReport += '\\n' + rdName + ' fps: ' + str(round(fps,3))        #Add FPS to report\n    tn\['COM_REPORT'].setValue(comReport)                                #Write report to COM_REPORT knob\n    nukebenchSetStatus('Ready', '', 'green')\n    \n    \n  \n  #ADD FINAL INFO TO REPORT  \n  comReport += '\\nCPU/GPU FRAMES: ' + str(end)\n  comReport += '\\nREAD/WRITE FRAMES: ' + str(ioEnd)\n  comReport += '\\nCHECKSUM: ' + str(nukebenchSimpleChecksum(comReport))\n  tn\['COM_REPORT'].setValue(comReport)\n\n\n#RUN THE MAIN FUNCTION\nrunNCtests()\n\n#UPDATE STATUS KNOB\nnukebenchSetStatus('Ready', '', 'green')" +STARTLINE}
 addUserKnob {26 status2 l "" -STARTLINE T "<font color =\"#54ff39\">Ready</font> "}
 addUserKnob {43 COM_REPORT l results t "Results of the simple benchmarks are shown here.\n\nCopy the results and submit them online to compare your results with other Nuke users around the world."}
 addUserKnob {22 copyResults l "Copy results to clipboard" t "Copy the results of the simple benchmark to the clipboard." T "#import subprocess\nfrom PySide2 import QtWidgets\n\ntn = nuke.thisNode()\nmsg = tn\['COM_REPORT'].value()\n\n# Set the text to the clipboard\nQtWidgets.QApplication.clipboard().setText(msg)\n\n\n\n\n#def nukebenchCopyText(message):\n#    \n#    # Convert the message to bytes for clipboard operation\n#    message_bytes = message.encode('utf-8')\n#\n#    # Platform-specific clipboard operation\n#    if nuke.env\['WIN32']:\n#        subprocess.Popen(\['clip'], stdin=subprocess.PIPE).communicate(input=message_bytes)\n#    elif nuke.env\['MACOS']:\n#        subprocess.Popen(\['pbcopy'], stdin=subprocess.PIPE).communicate(input=message_bytes)\n#    elif nuke.env\['LINUX']:\n#        subprocess.Popen(\['xclip', '-selection', 'clipboard'], stdin=subprocess.PIPE).communicate(input=message_bytes)\n\n\n\n\n  \n" +STARTLINE}
 addUserKnob {22 submit l "Share results online..." t "Copies the results to clipboard, then opens a web browser and navigates to the result submission form.\n\nShare and compare your results with other Nuke users around the world!" -STARTLINE T "from webbrowser import open as openUrl\n\ntn = nuke.thisNode()\n\ntn\['copyResults'].execute()\nopenUrl(\"http://www.pixelfudger.com/nukebench_form.html\")\n"}
 addUserKnob {1 subForm l URL t "If the 'Share results online...' button fails to open a web browser, you can copy the URL here and navigate to the page manually."}
 subForm http://www.pixelfudger.com/nukebench_form.html
 addUserKnob {26 ""}
 addUserKnob {26 nc_warning l "" +STARTLINE +HIDDEN T "<font size=2 color=#f7931e>Nuke Non-Commercial / Indie detected. Some features disabled due to Python limits.</font>"}
 addUserKnob {26 Credits l "" t "PxF_Nukebench 1.0 - &copy; 2023-2023 - Xavier Bourque - pixelfudger.com \n\nPixelfudger gizmos are free to use for personal and commercial use as long as you leave the credit text intact in the gizmo's knobs and in the source files. " +STARTLINE T "<font size=2>PxF_Nukebench 1.0 - &copy; 2023-2023 - </font><a href=\"http://www.xavierbourque.com\"><font color=\"#bbbbbb\" size=2>Xavier Bourque</a></font> - <a href=\"http://www.pixelfudger.com\"><font color=\"#bbbbbb\" size=2>pixelfudger.com</a></font> - <a href=\"http://www.pixelfudger.com/userguides/PxF_Nukebench.html\"><font color=\"#bbbbbb\" size=2>Video Tutorial</a></font>"}
 addUserKnob {20 Advanced}
 addUserKnob {6 incHWinfo l "Include Hardware Info" t "Include hardware information in the report, such as OS, amount of RAM, GPU model, CPU speed, etc..." +STARTLINE}
 incHWinfo true
 addUserKnob {6 runCPU l "CPU (ScanlineRender)" t "Run a CPU heavy test by rendering 50 moving and transparent cards in ScanlineRender.\n\nThe texture on the cards is different at each frame.\n\nThe resolution of the textures and final render is adjusted in the Preferences tab.\n\nThe render is done in a 'null' Write to remove disk IO speed from the calculation." +STARTLINE}
 runCPU true
 addUserKnob {6 useNew3D l "Use new 3D nodes (Nuke 14+)" t "Use the 'new' 3D nodes available in Nuke 14+ by using GeoCard instead of Card etc..." -STARTLINE}
 addUserKnob {6 runGPUZdefocus l "GPU (ZDefocus)" t "Run a GPU heavy test using the ZDefocus node.\n\nThe resolution of the image to defocus is adjusted in the Preferences tab.\n\nThe render is done in a 'null' Write to prevent slow disk/network from affecting the result." +STARTLINE}
 runGPUZdefocus true
 addUserKnob {6 useCPUZDefocus l "use CPU" t "Force the ZDefocus test to use CPU instead of GPU." -STARTLINE}
 addUserKnob {6 runGPUInference l "GPU (Inference)" t "Run a GPU heavy test using the Inference node. (Nuke 13+ only).\n\nInference is the node that runs the results of 'CopyCat'.\n\nYou need to specify the location of a .cat file in the Preferences tab for this test to run.\n\nYou can get pre-made .cat files from the Foundry's Cattery page.\n\nThe resolution of the image to run through the Inference node is adjusted in the Preferences tab.\n\nThe render is done in a 'null' Write to prevent slow disk/network from affecting the result." +STARTLINE}
 addUserKnob {6 useCPUInference l "use CPU" t "Render the Inference test using CPU instead of GPU (slow!)." -STARTLINE +DISABLED}
 addUserKnob {6 runWriteTest l "IO (Write)" t "Run the Write IO test.\n\nThis test renders colorbars with frame burn-in to disk.\n\nFrames will be written in the directory specified in 'temp files'.\n\nThe resolutions and file formats for the test are specified in the Preferences tab.\n\nThe number of frames is specified by the 'duration' knobs in the preferences." +STARTLINE}
 runWriteTest true
 addUserKnob {6 noisyWrite l "noisy image" t "Add noise to the ColorBars to stress test compressed codecs." -STARTLINE}
 noisyWrite true
 addUserKnob {6 runReadTest l "IO (Read)" t "Run the Read IO test.\n\nImages are Read straight from the Read nodes specified in the Read List (Preferences tab).\n\nThe number of frames is specified by the duration knobs in the preferences.\n\nThe images are read and immediatly 'written' to a 'null' Write to remove the Viewer as a variable.\n\nNuke's caches (RAM buffers, playback cache, disk cache) are cleared before each run.\n\nNote that most systems (Win, Mac, Linux) perform OS level RAM caching for files.\n\nYou may need to flush the OS RAM cache before running the Read IO test to get an accurate representation of your true disk speed.\n\nIf you read back frames you just wrote with the Write Test, you may read the frames from RAM via the OS instead of from disk.\n\nTo make sure the OS RAM cache is cleared (not to be confused with Nuke's memory buffers) you may want to run the Read Test right after a fresh machine boot.\n\nAlternately, to flush the OS RAM cache  on Windows, see the RamMap utility from Microsoft and use 'Empty Standby List' before running the Read Test." +STARTLINE}
 runReadTest true
 addUserKnob {6 runReadToViewer l "IO (Read to Viewer)" t "Run the Read to Viewer IO test.\n\nRead nodes specified in the Preferences tab will be read in the Viewer.\n\nThe number of frames is specified by the 'first' and 'last' knobs.\n\nA new Viewer is created for each Read and the frame rate is changed to 60 fps to account for fast file formats.\n\nNote that this feature is a bit experimental and may not be as stable or accurate as the standard IO Read test.\n\nThe same caveats about OS RAM cache that affect the regular Read test apply here too. (See IO Read tooltip)." +STARTLINE}
 addUserKnob {22 RUN_ALL l "Run benchmarks..." t "Run the selected benchmark tests." T "import nuke\nimport os\n\ndef runAllTests():\n  \n    tn                = nuke.thisNode()                    #This Nukebench node\n    \n    #Create utility functions used in multiple tests\n    tn\['INIT_FUNCTIONS'].execute()\n      \n\n    bp                = tn\['base_path'].value()            #Temp directory\n    incHWinfo         = tn\['incHWinfo'].value()            #Include hardware info\n    runCPU            = tn\['runCPU'].value()               #Run CPU test\n    runGPUZdefocus    = tn\['runGPUZdefocus'].value()       #Run GPU test\n    runGPUInference   = tn\['runGPUInference'].value()      #Run Inference test\n    runWriteTest      = tn\['runWriteTest'].value()         #Run Write test\n    runReadTest       = tn\['runReadTest'].value()          #Run Read test\n    runReadToViewer   = tn\['runReadToViewer'].value()      #Run Read to Viewer test\n    userAgree         = False                              #Assume user doesn't agree until otherwise\n    catfile           = os.path.abspath(os.path.expanduser(tn\['catFile'].value())).replace('\\\\','/')  # Path for inference cat file\n    rez_list          = tn\['rez_list'].value().split(',')  #List of all resolutions to test\n    rdl               = tn\['READ_LIST'].value()            #List of all Read nodes to test\n    type_list         = tn\['file_type_list'].value().split(',') #List of all file types to test\n    report            = tn\['IO_REPORT'].value()            #Report (advanced)\n    \n    sta               = 1                                  # Start frame\n    end               = int(tn\['last'].value())            #End frame (GPU/CPU)\n    ioSta             = 1                                  #Start frame\n    ioEnd             = int(tn\['ioLast'].value())          #End frame (WRITE test)\n    \n\n    \n    legalTypes        = \[]                                 #List of all file types available in Nukebench (Clunky, relies on knob labels -- should make the DICT in utility functions)\n    for type in tn\['file_type'].values():\n        splitType = type.split('/')\[-1]\n        if not splitType == '':\n            legalTypes.append(splitType)\n            \n    nkfmts = \[]                                            #List of all formats (HD_1080, UHD_4K, etc...) currently available in Nuke\n    for fmt in nuke.formats():\n        nkfmts.append(fmt.name())\n\n\n\n\n    # If no tests are enabled, warn the user and stop.\n    if not any((incHWinfo, runCPU, runGPUZdefocus, runGPUInference, runWriteTest, runReadTest, runReadToViewer)):\n        nuke.message(\"No test(s) selected. Benchmark stopped.\")\n\n    #If any tests with a Write node is enabled, check temp directory\n    if any((runCPU, runGPUZdefocus, runGPUInference, runWriteTest)):\n      #Check if temp files path is empty\n      if bp == '':\n        if nuke.ask('No temp directory specified. This directory is used to write temporary files. Do you want to choose one now?'):\n          bp = nuke.getFilename('Pick a temp directory.', '')\n          if bp == None:\n            return\n          else:\n            tn\['base_path'].setValue(bp)\n        else:\n          return\n          \n      # Check if temp files directory exists.\n      if not os.path.isdir(bp):\n          nuke.message('Please specify valid temp files directory.\\n(' + bp + ') is not a directory.' )\n          return\n  \n      # Add a leading '/' to temp file directory if missing\n      if not (bp\[-1] == '/'):\n          bp += '/'\n          tn\['base_path'].setValue(bp)\n\n    #If any test with a Write component is enabled, check if user resolutions are legit\n    if any((runCPU, runGPUZdefocus, runGPUInference, runWriteTest)):\n      # Check if all rez in test resolutions are legit\n      for rez in rez_list:\n          if not rez in nkfmts:\n              nuke.message \\\n                  ('Unknown resolution (' + rez + ') in Preferences -> Test Resolutions List.\\nPlease use valid comma (,) separated formats.\\nBenchmark stopped')\n              return\n  \n    # If the Write test is enabled, Check if all file types in file type list are legit\n    if runWriteTest:\n      for type in type_list:\n          if not type in legalTypes:\n              nuke.message \\\n                  ('Unknown file type (' + type + ') in Preferences -> Write file types list.\\nPlease use valid comma (,) separated file types.\\nBenchmark stopped')\n              return\n  \n    \n    if runGPUInference:\n      #Warn user when trying to run Inference test in nuke 12 or below\n      if nuke.NUKE_VERSION_MAJOR <=12:\n        nuke.message('Nuke v12 or below. Unable to run Inference test.\\nBenchmark stopped.')\n        return\n        \n      #Check if catfile exists on disk\n      if not os.path.exists(catfile):\n        nuke.message('Inference file (' + catfile + ') not found.\\nPlease adjust preferences or disable Inference test.\\nBenchmark stopped.')\n        return\n      \n      #Check if cat file is .cat extension\n      if not os.path.split(catfile)\[1].split('.')\[1] == 'cat':\n        nuke.message('Inference file (' + catfile + ') not a cat file.\\nPlease adjust preferences or disable Inference test.\\nBenchmark stopped.')\n        return\n          \n    # Check if Read Nodes list is empty\n    if runReadTest or runReadToViewer:\n        if rdl == \['']:  # If read list is empty...\n            nuke.alert(\"Preferences -> Read list is empty. Please run the Write test first to generate images to read.\\nBenchmark stopped.\")\n            return\n\n\n\n    ### START RUNNING TESTS HERE ####\n    \n    # Check if we can delete all nodes\n    if any ((runCPU, runGPUZdefocus, runGPUInference, runWriteTest)):  # If tests are destructive, warn user.\n        if tn\['userWarning'].value() == True:\n            if nuke.ask(\"This will DELETE EVERY NODE IN THIS NUKE SCRIPT. Continue?\"):\n                userAgree = True\n        elif tn\['userWarning'].value() == False:\n            userAgree = True\n        if userAgree:\n            for n in nuke.allNodes():\n                if n is not nuke.thisNode():\n                    nuke.delete(n)  # delete all nodes except this node\n                    tn\['READ_LIST'].setValue('')  # reset Read node list in prefs\n        else:\n            #nuke.alert(\"Benchmark stopped.\")\n            return\n\n    \n    #RUN ALL THE TESTS SELECTED BY THE USER\n    if incHWinfo:\n        tn\['BOX_INFO'].execute()\n\n    if runCPU:\n        tn\['CPU_SCANLINE_MULTICARD'].execute()\n\n    if runGPUZdefocus:\n        tn\['GPU_ZDEFOCUS'].execute()\n\n    if runGPUInference:\n        tn\['GPU_INFERENCE'].execute()\n\n    if runWriteTest:\n        tn\['IO_WRITE'].execute()\n\n    if runReadTest:\n        tn\['IO_READ_TO_NULL'].execute()\n        \n    # Run READ test - THIS MUST BE THE LAST TEST BECAUSE OF WACKY PROCESS CONTROL BOUNCING BETWEEN knobChanged() etc...\n    if runReadToViewer:\n        tn\['IO_READ_TO_VIEWER'].execute()\n    \n  \n\n#### RUN MAIN FUNCTION ####\nrunAllTests()\n\n\n#Update status\nnukebenchSetStatus('Ready', '', 'green')\n\n" +STARTLINE}
 addUserKnob {26 status l "" -STARTLINE T "<font color =\"#54ff39\">Ready</font> "}
 addUserKnob {43 IO_REPORT l report t "Results from the tests are added here. You can add custom notes if required.\n\nYou can also copy the results from here to add them to a spreadsheet like Excel or Google Sheets.\n\n(Google Sheets pro tip: use the \"Data -> Split Text To Columns\" feature to split the results using comma (,) as a separator)\n\n"}
 addUserKnob {22 clearIOreport l "Clear Report" t "Clear the report" T "nuke.thisNode()\['IO_REPORT'].setValue(\"\")\n" +STARTLINE}
 addUserKnob {20 Preferences}
 addUserKnob {6 userWarning l "Warn user before deleting all nodes" t "Warn user when about to delete all nodes in the current Nuke script." +STARTLINE}
 userWarning true
 addUserKnob {26 ""}
 addUserKnob {3 last l "CPU/GPU duration" t "Amount of frames of the CPU/GPU tests.\n\nIf your test runs too quickly (inaccurate) or too slowly (impractical), adjust the amount of frames here.\n\nYou should aim for CPU/GPU tests to take at about 2-3 minutes to have precise results.\n\nA good starting point should be 25 frames.\n\nYou can make the test much longer if you want to stress test the system stability."}
 last 50
 addUserKnob {3 ioLast l "READ/WRITE duration" t "Amount of frames of the READ/WRITE tests.\n\nIf your test runs too quickly (inaccurate) or too slowly (impractical), adjust the amount of frames here.\n\nThis will also determine how much disk space is required for the Write test.\n\nA good starting point should be 100 frames."}
 ioLast 250
 addUserKnob {26 ""}
 addUserKnob {17 format l " " t "Format picker to quickly add formats/resolutions to the 'Test resolution(s)' list." -STARTLINE}
 format "1920 1080 0 0 1920 1080 1 HD_1080"
 addUserKnob {1 rez_list l "Test resolution(s)" t "Specify which formats/resolutions you want to perform the tests with.\n\nTo run tests at multiple resolutions, specify multiple formats separated with a comma (,)."}
 rez_list HD_1080
 addUserKnob {22 clearRezList l Clear t "Clear the Test resolution(s) list." -STARTLINE T "tn = nuke.thisNode()\ntn\['rez_list'].setValue('')\n"}
 addUserKnob {26 ""}
 addUserKnob {68 file_type l " " t "File type picker to quickly add file types to the File type list.\n\nEXR16 = OpenEXR 16 bits half float\nEXR32 = OpenEXR 32 bits float\nJPG = JPEG, the number is the compression percentage. 95% = very good quality.\nDPX = DPX, BE/LE means big/little endian.\nMOV = Apple ProRes movie file.\nCIN = Cineon\nHDR = Radiance high dynamic range format, 16 bits half float\nMXF = Avid DNxHR Material Exchange Format\nPIC = Softimage 8 bits\nPNG = Lossless 8 or 16 bit integer\nSGI = Silicon Graphics format\nTGA = Targa\nTIF = TIFF\nNULL = 'null' write (i.e. dummy Write that doesn't write anything to disk).\n" M {"File types" EXR16/EXR16_none EXR16/EXR16_Zip_1_scanline EXR16/EXR16_Zip_16_scanline EXR16/EXR16_PIZ_32_scanlines EXR16/EXR16_RLE EXR16/EXR16_B44 EXR16/EXR16_B44A EXR16/EXR16_DWAA_200 EXR16/EXR16_DWAA_50 EXR16/EXR16_DWAB_200 EXR16/EXR16_DWAB_50 EXR32/EXR32_none EXR32/EXR32_Zip_1_scanline EXR32/EXR32_Zip_16_scanline EXR32/EXR32_PIZ_32_scanlines EXR32/EXR32_RLE EXR32/EXR32_B44 EXR32/EXR32_B44A EXR32/EXR32_DWAA_200 EXR32/EXR32_DWAA_50 EXR32/EXR32_DWAB_200 EXR32/EXR32_DWAB_50 JPG/JPEG_95 JPG/JPEG_75 JPG/JPEG_50 DPX/DPX_8_bit_BE DPX/DPX_10_bit_BE DPX/DPX_12_bit_BE DPX/DPX_16_bit_BE DPX/DPX_8_bit_LE DPX/DPX_10_bit_LE DPX/DPX_12_bit_LE DPX/DPX_16_bit_LE MOV/MOV_ProRes_Proxy_10_bit MOV/MOV_ProRes_LT_422_10_bit MOV/MOV_ProRes_422_10_bit MOV/MOV_ProRes_422_HQ_10_bit MOV/MOV_ProRes_4444_12_bit MOV/MOV_ProRes_4444_XQ_12_bit CIN/CINEON HDR/HDR MXF/MXF_444_12_bit MXF/MXF_HQX_12_bit MXF/MXF_HQ_8_bit MXF/MXF_SQ_8_bit MXF/MXF_LB_8_bit PIC/SOFTIMAGE_PIC PNG/PNG_8_bit PNG/PNG_16_bit SGI/SGI_8_bit SGI/SGI_16_bit TGA/TARGA TIF/TIFF_8_bit TIF/TIFF_8_bit_PackBits TIF/TIFF_8_bit_LZW TIF/TIFF_8_bit_Deflate TIF/TIFF_16_bit TIF/TIFF_16_bit_PackBits TIF/TIFF_16_bit_LZW TIF/TIFF_16_bit_Deflate TIF/TIFF_32_bit TIF/TIFF_32_bit_PackBits TIF/TIFF_32_bit_LZW TIF/TIFF_32_bit_Deflate NULL/NULL "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" ""}}
 addUserKnob {68 fileTypeShortcuts l "" t "File type shortcuts.\n\nQuickly add multiple file types to the file type list.\n\nNumber = the bit depth (8,10,12,16 or 32 bits per channel).\n\nFloat = Formats that support color values outside of the 0 to 1 range.\n\nInteger = Formats that support only color values between 0 and 1.\n\nLossless = Formats that are either uncompressed or using 'lossless' compression (i.e. invisible compression, larger files)\n\nLossy = Formats that use 'lossy' compression (i.e. compression that may introduce visible artefacts in the recorded image, smaller files)." -STARTLINE M {Shortcuts "32/32 float lossless" "32/32 float lossy" "16/16 float lossless" "16/16 float lossy" "16/16 integer lossless" "16/16 integer lossy" "12/12 integer lossless" "12/12 integer lossy" "10/10 integer lossless" "10/10 integer lossy" "8/8 integer lossless" "8/8 integer lossy" "" ""}}
 addUserKnob {1 file_type_list l "Write file type(s)" t "Specify which file formats you want to perform the IO Write tests with.\n\nTo run tests with multiple file formats, specify multiple formats separated with a comma (,)."}
 file_type_list EXR32_none,EXR16_Zip_1_scanline
 addUserKnob {22 clearFileTypeList l Clear t "Clear the Write file type list." -STARTLINE T "tn = nuke.thisNode()\ntn\['file_type_list'].setValue('')"}
 addUserKnob {26 ""}
 addUserKnob {2 catFile l "Inference .cat file" t "Path to the RealESRGAN Inference .cat file (not bundled with Nuke by default).\n\nThis is used for the Inference test.\n\nRealESRGAN can be downloaded for free on the Cattery page on Foundry's website. \n\nRealESRGAN is a machine learning model that upscales an image x4. It is good for testing GPU memory speed."}
 catFile ~/.nuke/Cattery/RealESRGAN/realesrgan.cat
 addUserKnob {4 inferenceScale l "Inference scale" t "Use this to lower the resolution for the GPU Inference test.\n\n(RealESRGAN is extremely GPU memory intensive and may fail with large Test resolutions)" M {1:1 1:2 1:4 1:8 1:16 "" "" "" "" "" "" "" "" ""}}
 inferenceScale 1:4
 addUserKnob {26 goToCattery l "" t "Go to the Cattery page in an internet browser..." -STARTLINE T "<font size=2>Go to the </font><a href=\"https://community.foundry.com/cattery\"><font color=\"#bbbbbb\" size=2>Foundry Cattery</a></font>"}
 addUserKnob {26 ""}
 addUserKnob {1 READ_LIST l "Read test node(s)" t "Which Read nodes to read in the IO Read test.\n\nThis list is populated automatically by the IO Write test when it is complete.\n\nYou can add the name of your own Read nodes here if you want to test special file formats not available to the Write test (for example Red .R3D files)."}
 addUserKnob {22 clearReadList l Clear t "Clear the Read nodes list." -STARTLINE T "tn = nuke.thisNode()\ntn\['READ_LIST'].setValue('')"}
 addUserKnob {22 pickReads l "Add Selected Reads" t "Add the Read nodes currently selected in the node graph to the Read node list." T "tn = nuke.thisNode()\nrdt = tn\['READ_LIST'].value()\nif rdt:\n  rdl = tn\['READ_LIST'].value().split(',')\nelse:\n  rdl = \[]\nfor n in nuke.selectedNodes():\n  if n.Class() == 'Read':\n    rdl.append(n.name())\n\ntn\['READ_LIST'].setValue(\",\".join(rdl))" +STARTLINE}
 addUserKnob {20 Employees_Only l "Employees Only" +INVISIBLE}
 addUserKnob {22 BOX_INFO T "import nuke\nimport psutil\nimport platform\nimport os\n\n#############\n#GATHER VARIOUS HARDWARE/SOFTWARE SPECS ABOUT THE SYSTEM\n#############\n\ntn         = nuke.thisNode()\nbp         = tn\['base_path'].value()                                        #Temp directory\ncp         = tn\['cachepath'].value()                                        #Cache directory\nreport     = tn\['IO_REPORT'].value()                                        #User report for advanced benchmarks\ncomReport  = tn\['COM_REPORT'].value()                                       #User report for simple benchmarks\nnukeVer    = nukebenchGetNukeVer()                                       #Current Nuke version\nhost       = platform.node()                                                #Hostname\ngpu        = nuke.toNode('preferences')\['selectedGPUDeviceIndex'].value()   #GPU name\ncpuCores   = psutil.cpu_count(logical=False)                                #Number of CPU cores\ncpuThreads = psutil.cpu_count(logical=True)                                 #Number of CPU threads\nram        = round(psutil.virtual_memory().total / (1023**3),0)             #Amount of RAM in GB\ncpuFreq    = nukebenchGetCPUFreq()\n \nif len(report) > 0:                                                         #If the report is not empty\n  report += '\\n\\n'                                                          #Add 2 new lines\nreport += '--------------------------------------'                          #Add separator\nreport += '\\n' + host                                                       #Build rest of report...\nreport += '\\nNuke ' + nukeVer\nreport += '\\n' + nukebenchGetPrettyOSName()\nreport += '\\nRAM: ' + str(int(ram)) + ' GB'\nreport += '\\n' + gpu\nreport += '\\n' + nukebenchGetPrettyCPUName()\['name']\nreport += '\\n' + nukebenchGetPrettyCPUName()\['cores']\nreport += '\\nBenchmark Temp files: ' + bp\nreport += '\\nNuke Cache: ' + cp\nreport += '\\n--------------------------------------'\n\ntn\['IO_REPORT'].setValue(report)                                           #Write report to IO_REPORT knob\n\n\n#Update status to ready in case following steps fail\nnukebenchSetStatus('Ready', '', 'green')\n\n" +STARTLINE}
 addUserKnob {22 INIT_FUNCTIONS T "import os\nimport nukescripts\n\n###########\n#DEFINE VARIOUS UTILITY FUNCTIONS\n###########\n\n#CHECK IF A PYTHON MODULE IS AVAILABLE\ndef moduleExists(module_name):\n    try:\n        __import__(module_name)\n        return True\n    except ImportError:\n        return False\n\n#GET THE FILESIZE OF AN IMAGE SEQUENCE\ndef nukebenchGetClipSize(clip,clipstart,clipend):                #Clip = /some/path/myclip/myclip.%04d.exr\n    clip = clip.replace(\"//\", \"/\")\n    basepath = os.path.split(clip)\[0]                            #Get clip parent directory (ex: /some/path/myclip/)\n    clipname = os.path.split(clip)\[1]                            #Get clip only             (ex: myclip.%04d.exr)\n    extension = clipname.split('.')\[-1]                          #Get file extension        (ex: .exr)\n    total_size = 0                                               #Initialize var for final size\n    \n    if extension.lower() in \['mov','mxf','r3d']:                 #If extension is either .mov, .mxf, r3d...\n        if os.path.exists(clip):                                 #If the file exists on disk...\n            total_size = os.path.getsize(clip)                   #Get the file size and put it in total_size\n        else:                                                    #If file doesn't exist...\n            print(\"File not found \" + file)                      #Print error msg\n            \n    elif extension == 'null':                                    #If it is a null write...\n      total_size = 0                                             #Set size to 0 bytes\n      \n    else:                                                        #If it's any other extension...\n      for frame_number in range(clipstart, clipend + 1):         #For each frame...\n          file_path = os.path.join(basepath, clipname % frame_number) # Construct the file path for the current frame\n          if os.path.exists(file_path):                          #If the current frame exists...\n              file_size = os.path.getsize(file_path)             #Get the file size for the frame...\n              total_size += file_size                            #... and add it to the total size\n          else:                                                  #If the frame doesn't exist on disk...\n              print(\"Frame not found \" + file_path)              #Print error msg\n    return total_size                                            #Return total clip size in bytes\n\n#CLEAR CACHES\ndef nukebenchClearCaches():\n  if hasattr(nuke, 'memory2'):\n    nuke.memory2.clearUsage()\n  nuke.clearDiskCache()\n  nuke.clearRAMCache()\n  nuke.clearBlinkCache()\n  nukescripts.clearAllCaches()\n\n#GET THE PRETTY NUKE VERSION\ndef nukebenchGetNukeVer():\n  nukeVer = nuke.NUKE_VERSION_STRING\n  if nuke.env\['nc']:\n    nukeVer = nukeVer + \" NC\"\n  if nuke.env\['indie']:\n    nukeVer = nukeVer + \" Indie\"\n  return nukeVer\n\n#GET THE PRETTY OS NAME (i.e. 'Windows 10', 'Rocky Linux 9', etc...)\ndef nukebenchGetPrettyOSName():\n  import platform\n  osName = platform.system()\n  osRelease = platform.release()\n  prettyOSName = ''\n  \n  if nuke.env\['LINUX']:\n    distro = platform.freedesktop_os_release()\['NAME']\n    version = platform.freedesktop_os_release()\['VERSION_ID']\n    prettyOSName = distro + ' ' + version + ' / ' + osRelease\n    \n  elif nuke.env\['MACOS']:\n    prettyOSName = 'Mac OSX ' + platform.mac_ver()\[0]\n\n  elif nuke.env\['WIN32']:\n    prettyOSName = osName + ' ' + osRelease\n  return prettyOSName\n\n\n\n#GET THE PRETTY CPU NAME (i.e. Intel(R) Core(TM) i7-6700K CPU @ 4.00GHz) AND PRETTY CORE/THREAD/CLOCK (i.e. 4 / 8 / 3.6)\ndef nukebenchGetPrettyCPUName():\n  prettyCPUName = \{\}\n  prettyCPUName\['name'] = ''\n  prettyCPUName\['cores'] = ''\n  cpuCores = psutil.cpu_count(logical=False)\n  cpuThreads = psutil.cpu_count(logical=True)\n  cpuFreq = nukebenchGetCPUFreq()\n\n\n  #IF OS IS LINUX, GET CPU INFO FROM /proc/cpuinfo\n  if nuke.env\['LINUX']:\n    if os.path.exists('/proc/cpuinfo'):\n      file = open('/proc/cpuinfo', 'r')\n      lines = file.readlines()\n      for line in lines:\n        if line.startswith('model name'):\n          cpuname = line.split(':')\[1].strip()\n      prettyCPUName\['name'] = cpuname\n      file.close()\n  \n  #IF OS IS MAC OS, GET CPU INFO FROM sysctl\n  elif nuke.env\['MACOS']:\n    import subprocess\n    prettyCPUName\['name'] = subprocess.check_output('sysctl -n machdep.cpu.brand_string', shell=True).decode().strip()\n\n  #IF OS IS WINDOWS, GET CPU INFO FROM Registry\n  elif nuke.env\['WIN32']:\n    if moduleExists('winreg'):\n      import winreg as winreg\n    elif moduleExists('_winreg'):\n      import _winreg as winreg\n    else:\n      return ''\n    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, \"HARDWARE\\\\DESCRIPTION\\\\System\\\\CentralProcessor\\\\0\")\n    prettyCPUName\['name'] = winreg.QueryValueEx(key, \"ProcessorNameString\")\[0].strip()\n    winreg.CloseKey(key)\n    \n  #FORMAT THE CORES/THREADS FROM psutil AND RETURN THEM IN A SEPARATE ITEM\n  prettyCPUName\['cores'] = str(cpuCores) + ' cores / ' + str(cpuThreads) + ' threads'\n  if not cpuFreq == 0:\n    prettyCPUName\['cores'] += ' / ' + str(cpuFreq) + ' GHz'\n  \n  #RETURN prettyCPUName LIST WITH NAME AND CORE COUNT\n  return prettyCPUName\n\n\n#GET THE MAX CLOCK SPEED OF THE CPU\ndef nukebenchGetCPUFreq():\n    cpuFreq    = 0                                                              #Initialize cpuFreq integer\n    if hasattr(psutil, 'cpu_freq'):                                             #Check if psutil module has 'cpu_freq' function (older versions don't)\n        cpuFreq = round(psutil.cpu_freq().current / 1000, 1)                    #Get current CPU speed\n        if hasattr(psutil.cpu_freq() , 'max'):                                  #Check if cpu_freq().max is available\n          maxFreq = round(psutil.cpu_freq().max / 1000, 1)                      #Get max CPU speed in GHz\n          if maxFreq > cpuFreq:                                                 #If max is greater than current...\n            cpuFreq = maxFreq                                                   #Use max instead\n    \n    return cpuFreq\n    \n\n#DISPLAY STATUS MESSAGES IN THE 'status' TEXT KNOB.\ndef nukebenchSetStatus(msg,submsg,color):\n  tn = nuke.thisNode()\n  statkbs = \[tn\['status'], tn\['status2']]\n  colorcode = '#ffffff'\n  if color == 'green':\n    colorcode = '#54ff39'\n  elif color == 'orange':\n    colorcode = '#f7931e'\n  \n  msg = '<font color =\"' + colorcode + '\">' + msg + '</font> ' + submsg\n  \n  for kb in statkbs:\n    kb.setValue(msg) \n\n\n\n#COMPUTE CHECKSUM FROM REPORT (simple)\ndef nukebenchSimpleChecksum(report):\n  reportlines = report.split('\\n')                     #List of lines from the report\n  total = 6215450                                      #Total sum of each number in report\n  magicnumber = 979797                                 #Magic number\n\n  for line in reportlines:                             #For each line in report...\n    value = line.split(': ')\[1]                        #Get the part after the colon (:)\n    value = ''.join(c for c in value if c.isdigit())   #Remove everything except numbers\n\n    if len(value) > 6:                                 #If the string is more than 6 chars\n      value = value\[:6]                                #Keep only the first 6 chars\n\n    if len(value) > 0:                                 #If string is not empty\n      intvalue = int(value)                            #Convert string to integer\n    else:\n      intvalue = 0                                     #If string is empty use Zero\n\n    total = total + intvalue                           #Add the current number to prev numbers\n\n  checksum = total % magicnumber                       #Divide total by magicnumber, keep the remainder as checksum\n  return checksum                                      #Return checksum value\n\n\n\ndef nukebenchFindFont():\n    pref_fonts = \['Arial', 'Helvetica', 'Utopia', 'Courier']  # Preferred font names in order\n    fonts = nuke.getFonts()                                   # Get list of system fonts\n\n    for pref_font in pref_fonts:                       #For every pref_font...\n        for font in fonts:                             #Loop throught the system font list...\n            if font\[0] == pref_font:                   #If found the pref font...\n                return font\[2]                         # Return font path\n    return ''                                          #If no pref font found, return empty string\n    \n    \ndef nukebenchRepoNode(reponode,refnode,offsetx,offsety):\n  reponode\['xpos'].setValue(refnode\['xpos'].getValue() + offsetx)\n  reponode\['ypos'].setValue(refnode\['ypos'].getValue() + offsety)\n" +STARTLINE}
 addUserKnob {22 IO_WRITE T "import nuke\nimport time\nimport datetime\nimport os\nimport nukescripts\n\n\n##############\n#WRITE COLORBARS, BURN-IN AND NOISE TO DISK\n#TIME THE OPERATION\n##############\n\n\nglobal format_details   #Global so it can be picked up in createFormattedWrite() and readIOTest()\nglobal noisy            #Global so it can be picked up in createFormattedWrite() and readIOTest()\n\n\nnoisy = nuke.thisNode()\['noisyWrite'].value()              #Is noisy image enabled?\n\nformat_details = \{      #Define attributes of each format shorthand\n    'EXR16_none': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '16 bit half', 'compression': 'none'\},\n    'EXR16_Zip_1_scanline': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '16 bit half', 'compression': 'Zip (1 scanline)'\},\n    'EXR16_Zip_16_scanline': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '16 bit half', 'compression': 'Zip (16 scanlines)'\},\n    'EXR16_PIZ_32_scanlines': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '16 bit half', 'compression': 'PIZ Wavelet (32 scanlines)'\},\n    'EXR16_RLE': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '16 bit half', 'compression': 'RLE'\},\n    'EXR16_B44': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '16 bit half', 'compression': 'B44'\},\n    'EXR16_B44A': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '16 bit half', 'compression': 'B44A'\},\n    'EXR16_DWAA_200': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '16 bit half', 'compression': 'DWAA', 'dw_compression_level': 200\},\n    'EXR16_DWAA_50': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '16 bit half', 'compression': 'DWAA', 'dw_compression_level': 50\},\n    'EXR16_DWAB_200': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '16 bit half', 'compression': 'DWAB', 'dw_compression_level': 200\},\n    'EXR16_DWAB_50': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '16 bit half', 'compression': 'DWAB', 'dw_compression_level': 50\},\n    \n    'EXR32_none': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '32 bit float', 'compression': 'none'\},\n    'EXR32_Zip_1_scanline': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '32 bit float', 'compression': 'Zip (1 scanline)'\},\n    'EXR32_Zip_16_scanline': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '32 bit float', 'compression': 'Zip (16 scanlines)'\},\n    'EXR32_PIZ_32_scanlines': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '32 bit float', 'compression': 'PIZ Wavelet (32 scanlines)'\},\n    'EXR32_RLE': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '32 bit float', 'compression': 'RLE'\},\n    'EXR32_B44': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '32 bit float', 'compression': 'B44'\},\n    'EXR32_B44A': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '32 bit float', 'compression': 'B44A'\},\n    'EXR32_DWAA_200': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '32 bit float', 'compression': 'DWAA', 'dw_compression_level': 200\},\n    'EXR32_DWAA_50': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '32 bit float', 'compression': 'DWAA', 'dw_compression_level': 50\},\n    'EXR32_DWAB_200': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '32 bit float', 'compression': 'DWAB', 'dw_compression_level': 200\},\n    'EXR32_DWAB_50': \{'ext': 'exr', 'file_type': 'exr', 'datatype': '32 bit float', 'compression': 'DWAB', 'dw_compression_level': 50\},\n\n    'JPEG_95': \{'ext': 'jpg', 'file_type': 'jpeg', '_jpeg_quality': 0.95, '_jpeg_sub_sampling': '4:1:1'\},\n    'JPEG_75': \{'ext': 'jpg', 'file_type': 'jpeg', '_jpeg_quality': 0.75, '_jpeg_sub_sampling': '4:1:1'\},\n    'JPEG_50': \{'ext': 'jpg', 'file_type': 'jpeg', '_jpeg_quality': 0.50, '_jpeg_sub_sampling': '4:1:1'\},\n    'DPX_8_bit_BE': \{'ext': 'dpx', 'file_type': 'dpx', 'datatype': '8 bit', 'bigEndian': True\},\n    'DPX_10_bit_BE': \{'ext': 'dpx', 'file_type': 'dpx', 'datatype': '10 bit', 'bigEndian': True\},\n    'DPX_12_bit_BE': \{'ext': 'dpx', 'file_type': 'dpx', 'datatype': '12 bit', 'bigEndian': True\},\n    'DPX_16_bit_BE': \{'ext': 'dpx', 'file_type': 'dpx', 'datatype': '16 bit', 'bigEndian': True\},\n    'DPX_8_bit_LE': \{'ext': 'dpx', 'file_type': 'dpx', 'datatype': '8 bit', 'bigEndian': False\},\n    'DPX_10_bit_LE': \{'ext': 'dpx', 'file_type': 'dpx', 'datatype': '10 bit', 'bigEndian': False\},\n    'DPX_12_bit_LE': \{'ext': 'dpx', 'file_type': 'dpx', 'datatype': '12 bit', 'bigEndian': False\},\n    'DPX_16_bit_LE': \{'ext': 'dpx', 'file_type': 'dpx', 'datatype': '16 bit', 'bigEndian': False\},\n    'MOV_ProRes_Proxy_10_bit': \{'ext': 'mov', 'file_type': 'mov', 'meta_encoder':'mov64', 'mov64_format':'mov (QuickTime / MOV)', 'mov64_codec':'appr', 'mov_prores_codec_profile': 'ProRes 4:2:2 Proxy 10-bit'\},\n    'MOV_ProRes_LT_422_10_bit': \{'ext': 'mov', 'file_type': 'mov', 'meta_encoder':'mov64', 'mov64_format':'mov (QuickTime / MOV)', 'mov64_codec':'appr', 'mov_prores_codec_profile': 'ProRes 4:2:2 LT 10-bit'\},\n    'MOV_ProRes_422_10_bit': \{'ext': 'mov', 'file_type': 'mov', 'meta_encoder':'mov64', 'mov64_format':'mov (QuickTime / MOV)', 'mov64_codec':'appr', 'mov_prores_codec_profile': 'ProRes 4:2:2 10-bit'\},\n    'MOV_ProRes_422_HQ_10_bit': \{'ext': 'mov', 'file_type': 'mov', 'meta_encoder':'mov64', 'mov64_format':'mov (QuickTime / MOV)', 'mov64_codec':'appr', 'mov_prores_codec_profile': 'ProRes 4:2:2 HQ 10-bit'\},\n    'MOV_ProRes_4444_12_bit': \{'ext': 'mov', 'file_type': 'mov', 'meta_encoder':'mov64', 'mov64_format':'mov (QuickTime / MOV)', 'mov64_codec':'appr', 'mov_prores_codec_profile': 'ProRes 4:4:4:4 12-bit'\},\n    'MOV_ProRes_4444_XQ_12_bit': \{'ext': 'mov', 'file_type': 'mov', 'meta_encoder':'mov64', 'mov64_format':'mov (QuickTime / MOV)', 'mov64_codec':'appr', 'mov_prores_codec_profile': 'ProRes 4:4:4:4 XQ 12-bit'\},\n    'CINEON': \{'ext': 'cin', 'file_type': 'cin' \},\n    'HDR': \{'ext': 'hdr', 'file_type': 'hdr' \},\n    'MXF_444_12_bit': \{'ext': 'mxf', 'file_type': 'mxf', 'mxf_codec_profile_knob': '4:4:4 12-bit'\},\n    'MXF_HQX_12_bit': \{'ext': 'mxf', 'file_type': 'mxf', 'mxf_codec_profile_knob': 'HQX 4:2:2 12-bit'\},\n    'MXF_HQ_8_bit': \{'ext': 'mxf', 'file_type': 'mxf', 'mxf_codec_profile_knob': 'HQ 4:2:2 8-bit'\},\n    'MXF_SQ_8_bit': \{'ext': 'mxf', 'file_type': 'mxf', 'mxf_codec_profile_knob': 'SQ 4:2:2 8-bit'\},\n    'MXF_LB_8_bit': \{'ext': 'mxf', 'file_type': 'mxf', 'mxf_codec_profile_knob': 'SQ 4:2:2 8-bit'\},\n    'SOFTIMAGE_PIC': \{'ext': 'pic', 'file_type': 'pic' \},\n    'PNG_8_bit': \{'ext': 'png', 'file_type': 'png', 'datatype': '8 bit' \},\n    'PNG_16_bit': \{'ext': 'png', 'file_type': 'png', 'datatype': '16 bit' \},\n    'SGI_8_bit': \{'ext': 'sgi', 'file_type': 'sgi', 'datatype': '8 bit'\},\n    'SGI_16_bit': \{'ext': 'sgi', 'file_type': 'sgi', 'datatype': '16 bit'\},\n    'TARGA': \{'ext': 'tga', 'file_type': 'targa' \},\n    'TIFF_8_bit': \{'ext': 'tif', 'file_type': 'tiff', 'datatype': '8 bit', 'compression': 'none'\},\n    'TIFF_8_bit_PackBits': \{'ext': 'tif', 'file_type': 'tiff', 'datatype': '8 bit', 'compression': 'PackBits'\},\n    'TIFF_8_bit_LZW': \{'ext': 'tif', 'file_type': 'tiff', 'datatype': '8 bit', 'compression': 'LZW'\},\n    'TIFF_8_bit_Deflate': \{'ext': 'tif', 'file_type': 'tiff', 'datatype': '8 bit', 'compression': 'Deflate'\},\n    'TIFF_16_bit': \{'ext': 'tif', 'file_type': 'tiff', 'datatype': '16 bit', 'compression': 'none'\},\n    'TIFF_16_bit_PackBits': \{'ext': 'tif', 'file_type': 'tiff', 'datatype': '16 bit', 'compression': 'PackBits'\},\n    'TIFF_16_bit_LZW': \{'ext': 'tif', 'file_type': 'tiff', 'datatype': '16 bit', 'compression': 'LZW'\},\n    'TIFF_16_bit_Deflate': \{'ext': 'tif', 'file_type': 'tiff', 'datatype': '16 bit', 'compression': 'Deflate'\},\n    'TIFF_32_bit': \{'ext': 'tif', 'file_type': 'tiff', 'datatype': '32 bit', 'compression': 'none'\},\n    'TIFF_32_bit_PackBits': \{'ext': 'tif', 'file_type': 'tiff', 'datatype': '32 bit', 'compression': 'PackBits'\},\n    'TIFF_32_bit_LZW': \{'ext': 'tif', 'file_type': 'tiff', 'datatype': '32 bit', 'compression': 'LZW'\},\n    'TIFF_32_bit_Deflate': \{'ext': 'tif', 'file_type': 'tiff', 'datatype': '32 bit', 'compression': 'Deflate'\},\n    'NULL': \{'ext': 'null', 'file_type': 'null', 'label': 'null'\},\n    # Add more formats here...\n\}\n\n\n\n\n\n\n# Utility function to create a Write node based on the selected file format and resolution\ndef createFormattedWrite(ff,rz):\n    import re\n    \n    global noisy\n    global format_details\n    bp = nuke.thisNode()\['base_path'].value()                                       #Path to temp directory to write files\n    fmt = format_details.get(ff)                                                    #Get dict of various knob values for specific format (ex: EXR16_DWAA, JPEG_95, etc...)\n    if fmt:                                                                         #If fmt is not empty then...\n        ext = fmt.get('ext', '')                                                    #Get the file extension (ex: .exr)\n        wt = nuke.createNode('Write', inpanel=False)                                #Create a Write node\n        if noisy:                                                                   #If noisy is enabled...\n          nf = '_NS_'                                                               #Set noisy flag to '_NS_' (noisy)\n        else:                                                                       #If noisy flag is disabled...\n          nf = '_CL_'                                                               #Set noisy flag to '_CL_' (clean)\n        \n        rezNoiseFormat = rz + nf + ff\n        rezNoiseFormat = re.sub(r'\[^A-Za-z0-9_]', '_', rezNoiseFormat)\n        \n        wt.setName('WRITE_' + rezNoiseFormat)                                         #Set node name\n        if ext in \['mov','mxf']:                                                    #If extension is mov or mfx then...\n          pad = '.'                                                                 #Set the pad to '.'\n        else:\n          pad = '.%04d.'                                                            #Otherwise it's an image sequence, so set pad to .%04d.\n        wt\['file'].setValue(bp + rezNoiseFormat + '/' + rezNoiseFormat + pad + ext)     #Build full file path\n        if ext != 'null':                                                           #If extension is not 'null'...\n          wt\['create_directories'].setValue(1)                                      #...enable create directories\n\n        # Set other knob values based on the format_details\n        for knob_name, knob_value in fmt.items():                                   #For each item in the format details dict...\n          if knob_name != 'ext':                                                    #If the knob is not 'ext' then...                                                 \n            wt\[knob_name].setValue(knob_value)                                      #Set the knob value\n        return wt                                                                   #Return the node object of the Write node\n    else:                                                                           #Else if the user wants a format that doesn't exist in format_details then...\n        nuke.alert(\"File type (\" + ff + \") not found.\")                             #Pop an error message\n        return None                                                                 #Return nothing\n\n\n### Main function to start Write test \ndef writeIOtest():  \n  #SETUP SOME VARIABLES\n  global noisy                                               #This is global because 2 functions use it\n  benchNode = nuke.thisNode()                                #Node object for this node\n  ffl = benchNode\['file_type_list'].value().split(',')       #File formats list\n  rzl = benchNode\['rez_list'].value().split(',')             #Resolution list\n  wtl = \[]                                                   #Write nodes list   \n  rdl = \[]                                                   #Read nodes list\n  report = benchNode\['IO_REPORT'].value()                    #Final report (advanced benchmarks)\n  comReport = tn\['COM_REPORT'].value()                       #Finale report (simple benchmarks)\n  sta = 1\n  end = int(benchNode\['ioLast'].value())                     #End frame\n  cp = benchNode\['cachepath'].value()                        #CachePath... nuke disk cache location\n\n  #DELETE ALL NODES EXCEPT THIS NODE\n  for n in nuke.allNodes():\n    if n is not nuke.thisNode():\n      nuke.delete(n)\n      tn\['READ_LIST'].setValue('')\n\n\n  \n  #CREATE COLORBARS, NOISE AND WRITE NODES FOR ALL FORMATS\n  for rz in rzl:                                       #for each rez (HD_1080, UHD_4K, etc...) in rez list... \n    cb1 = nuke.createNode(\"ColorBars\", inpanel=False)  #create colorbars\n    cb1\['format'].setValue(rz)                         #set colorbars resolution\n    \n    if noisy:                                            #If 'noisy' is enabled...\n      dt1 = nuke.createNode(\"Expression\", inpanel=False) #Create an expression node\n      dt1.setInput(0,cb1)                                #Set input to colorbars\n      dt1\['temp_name0'].setValue('ran')                  #Setup expressions to add noise to image...\n      dt1\['temp_expr0'].setValue('((random(x*y*frame))-0.5)*0.03')\n      dt1\['expr0'].setValue('r+ran')\n      dt1\['expr1'].setValue('g+ran')\n      dt1\['expr2'].setValue('b+ran')\n    else:                                     #If noisy is disbled\n      dt1 = cb1                               #Skip the expression node, use colorbars as node dt1\n    \n    for ff in ffl:                                               #For each file format (EXR, JPG, etc...) from file format list\n\n#      tx1 = nuke.createNode(\"Text2\")                             #Create text node\n#      tx1.setInput(0,dt1)                                        #Connect input to noise/colorbars node\n#      tx1\['message'].setValue(rz + \" \" + ff + \" \[value frame]\")  #Add burn-in text with format info\n#      tx1\['global_font_scale'].setExpression(\"width/2000\")       #Adjust text size to fit frame width\n#\n\n      tx1 = nuke.createNode(\"Text\", inpanel=False)               #Create old school text node\n      tx1.setInput(0,dt1)                                        #Connect input to noise/colorbars node\n      ft = nukebenchFindFont()                                   #Get pref font path (Arial, Helvetica, Utopia, Courier)\n      if ft:                                                     #If we found a valid font path...\n        tx1\['font'].setValue(ft)                                 #... set the font knob\n      tx1\['message'].setValue(rz + \"\\n\" + ff + \"\\n\[value frame]\") #Add burn-in text with format info\n      tx1\['size'].setExpression(\"width/25\")                      #Adjust text size to fit frame width\n      tx1\['xjustify'].setValue(\"center\")                         #Center text\n      tx1\['box'].setValue((0,0,0,0))                             #Set corners to 0,0,0,0\n      tx1\['box'].setExpression('width', 2)                       #Set right side to right edge\n      tx1\['box'].setExpression('height', 3)                      #Set top to top side\n    \n      \n      wt = createFormattedWrite(ff,rz)                           #Create write node using createFormattedWrite() (see above)\n      if wt == None:                                             #If no write node is returned...\n        nuke.message('Failed to create formatted write.')        #error message\n        return                                                   \n      wt.setInput(0,tx1)                                         #Set input to text node\n      wtl.append(wt)                                             #Add write to Write List so we know later which Writes to render\n\n  \n  #CLEAN NODE GRAPH\n  nuke.selectAll()          #Select all nodes\n  nuke.autoplace_all()      #Autoplace (like hotkey L)\n  \n  #GENERATE REPORT HEADER\n  if len(report) > 0:                                                         #If the report is not empty...\n    report += \"\\n\\n\"                                                          #Add a new line    \n  report += \"--------------------------------------\"                          #Add separator\n  report += \"\\n\" + datetime.datetime.now().strftime(\"%Y/%m/%d %H:%M:%S\")      #Add date and time\n  report += \"\\n'Write' IO Test\"                                               #Add title\n  report += '\\n' + str(end-sta+1) + \" frames\"                                 #Add number of frames\n  if noisy:                                                                   #If 'noisy' is enabled...\n    report += ' (noisy)'                                                      #... add 'noisy' to report\n  else:                                                                       #If 'noisy' is disabled...\n    report += ' (clean)'                                                      #... add 'clean' to report\n  benchNode\['IO_REPORT'].setValue(report)                                     #Write report to IO_REPORT knob\n  \n\n\n  #CLEAR CACHES\n  nukebenchClearCaches()\n\n  #RENDER AND TIME EVERY WRITE NODE, LOG RESULTS IN REPORT\n  for wt in wtl:                                                                #For every Write in Write List...\n    nukebenchSetStatus('Running IO Write test...', wt.name(),'orange')          #Update status knob\n    clockStart = time.time()                                                    #Start time\n    nuke.render(wt,sta,end)                                                     #Render Write node from first to last frame\n    clockStop = time.time()                                                     #End time\n    clockDur = (clockStop-clockStart)                                           #Duration of the render in seconds\n    clipLength = (end-sta+1)                                                    #Clip length in frames\n    clipSize = nukebenchGetClipSize(wt\['file'].value(),sta,end) / 1024 / 1024   #Clip size in MBytes\n    frameSize = clipSize / clipLength                                           #Average frame size in MBytes\n    dataSpeed = clipSize / clockDur                                             #Average throughput in MB/s\n    fps = clipLength/clockDur                                                   #Average frames per second\n    #Add 1 line to report with all details above\n    report += \"\\n\" + wt.name() + \",\" + str(round(clockDur,2)) + \" seconds,\" + str(round(clipSize,1)) + \" MBytes,\" + str(round(frameSize,1)) + \" MB/frame,\" + str(round(dataSpeed,2)) + \" MBytes/s,\"+ str(round(fps,2)) + \" fps\"\n    benchNode\['IO_REPORT'].setValue(report)                                     #Write to IO_REPORT knob\n    \n \n\n  #ADD FOOTER TO REPORT\n  report += \"\\n--------------------------------------\"  #Add separator\n  benchNode\['IO_REPORT'].setValue(report)               #Dump report in IO_REPORT knob\n\n\n  #CREATE READ NODES FROM EACH WRITE SO WE CAN RUN THE READ TEST ON THEM LATER\n  for wt in wtl:                                   #For each Write in Write List...\n    if wt\['label'].value() != 'null':              #If it's not a null Write...\n      rd = nuke.createNode(\"Read\", inpanel=False)  #Create a Read node\n      rdl.append(rd)                               #Add Read node to Read List (to be picked up by READ_IO test)\n      nm = wt.name()                               #Name of Write node\n      nm = nm.replace(\"WRITE\",\"READ\")              #Replace word WRITE with READ\n      rd.setName(nm)                               #Set name of Read node\n      rd\['file'].setValue(wt\['file'].value())      #Set file path of Read node\n      rd\['first'].setValue(sta)                    #Set first frame of Read node\n      rd\['last'].setValue(end)                     #Set last frame of Read node\n      rd\['xpos'].setValue(wt\['xpos'].value())      #Set x position to match Write node\n      rd\['ypos'].setValue(wt\['ypos'].value()+60)   #Set y postition under Write node\n    \n  #Add each write node to the Read node list in preferences\n  rdnames = ''                                   #String of the names of each Read node\n  for r in rdl:                                  #For each read in read node list...\n    rdnames += r.name() + ','                    #Add name of Read node and ',' to string\n  benchNode\['READ_LIST'].setValue(rdnames\[:-1])  #Dump read list into READ_LIST knob... remove last ','\n\n\n#RUN MAIN FUNCTION  \nwriteIOtest()  \n\nnukebenchSetStatus('Ready', '', 'green')" +STARTLINE}
 addUserKnob {22 IO_READ_TO_VIEWER T "import time\nimport datetime\nimport nukescripts\nimport os\nimport nukescripts\n\n\n##############\n#PLAYBACK IMAGES FROM DISK IN THE VIEWER\n#TIME THE OPERATION\n##############\n\n\n#DEFINE CODE TO INJECT IN VIEWER'S knobChanged()\n# This code is injected into our freshly created Viewer so it self-checks\n# and stops at the last frame on its own\ndef viewerKnobChanged():\n  global end                                 #Which frame to stop (set by doReadBenchmark())\n  tn = nuke.thisNode()                       #This node (the Viewer)\n  tk = nuke.thisKnob()                       #This knob (the knob that was changed)\n  \n  if tk.name() == 'frame':                   #If the 'frame' knob from the Viewer changed...\n    if tk.value() == end:                    #... and if we're at the last frame\n      nuke.activeViewer().stop()             #Stop playback\n      tn\['format_center'].setValue(True)     #Change a random knob to force the UpdateUI callback to run\n      tn\['format_center'].setValue(False)    #Change it back\n                                             #next steps picked up by updateUI script (see contents of hidden knob VIEWER_UPDATEUI)\n\n\n\n####### MAIN SCRIPT STARTS HERE ##########\ndef doReadBenchmark():\n  global benchNode\n  global sta\n  global end\n  global rdl\n  global rdlidx\n  global clockStart\n  global clockEnd\n  global report\n  global vw\n  global clipSize\n  global prevRootFps\n  \n\n  benchNode         = nuke.thisNode()                         #This node (PxF_Nukebench)\n  sta               = 1                                       #Start frame\n  end               = int(benchNode\['ioLast'].value())        #End frame\n  if 'rdlidx' not in globals():                               #If rdlidx has never been initialized...\n    rdlidx = -1                                               #... init with -1 (this means this is the first run)\n  rdlstr            = benchNode\['READ_LIST'].value()          #String of Read nodes to benchmark (from knob in preferences)\n  rdl               = rdlstr.split(',')                       #... converted to a list\n  clockStart        = 0                                       #Init clockStart variable\n  clockEnd          = 0                                       #Init clockEnd variable\n  report            = benchNode\['IO_REPORT'].value()          #Report\n  \n\n\n\n  #THIS STUFF RUNS BEFORE THE FIRST PLAYBACK\n  if rdlidx == -1:                                #If this is the first pass...\n    nr = nuke.Root()                              #Get node object of the Root node (Nuke prefs)\n    prevRootFps = nr\['fps'].value()               #Get current viewer FPS\n    nr\['fps'].setValue(60)                        #Set value to 60 fps (to test formats that run faster than 24fps)\n    nr\['first_frame'].setValue(sta)               #Set global range (first)\n    nr\['last_frame'].setValue(end)                #Set global range (last) to avoid playback looping before end of test\n    nr\['proxy'].setValue(False)                   #Disable proxy mode\n\n    \n    if len(report) > 0:                                                    #If report is not empty...                          \n      report += \"\\n\\n\"                                                     #Add new line\n    report += \"--------------------------------------\"                     #Add separator\n    report += \"\\n\" + datetime.datetime.now().strftime(\"%Y/%m/%d %H:%M:%S\") #Add date and time\n    report += \"\\n'Read to Viewer' IO Test\"                                 #Add title line\n    report += \"\\n\" + str(int(end-sta+1)) + \" frames\"                       #Add test number of frames\n    rdlidx = 0                                                             #Set rdlidx to 0 (we are done with 'first run' things to do)\n\n\n\n  #THIS STUFF RUNS AFTER THE LAST PLAYBACK\n  if rdlidx == len(rdl):                                         #If we're at the end of the list of Reads to bench...\n    report = report + \"\\n--------------------------------------\" #Add separator\n    benchNode\['IO_REPORT'].setValue(report)                      #Write report to IO_REPORT knob\n    report = ''                                                  #Reset report variable\n    rdlidx = -1                                                  #Reset rdlidx to -1. This will trigger 'first run' things next time button is pushed\n    nuke.delete(vw)                                              #Delete the Viewer we created\n    nuke.Root()\['fps'].setValue(prevRootFps)                     #Set the fps back to what it was before we ran test\n    nukebenchSetStatus('Ready', '','green')                      #We are done, set status to 'Ready'        \n    return                                                       #Exit\n    \n  \n  #THIS STUFF RUNS FOR EVERY PLAYBACK\n  \n  #Delete all Viewers\n  for n in nuke.allNodes():\n    if n.Class() == \"Viewer\":\n      nuke.delete(n)\n    \n  #Clear caches\n  nukebenchClearCaches()\n\n  \n  #Create, setup Viewer. Start playback.\n  vw = nuke.createNode(\"Viewer\")                               #Create a Viewer node\n  rd = nuke.toNode(rdl\[rdlidx])                                #Read node we are currently playing back\n  nukebenchSetStatus('Running IO Read to Viewer test...', rd.name(),'orange')\n  vw.setInput(0,rd)                                            #Connect Viewer input to Read\n  vw\['full_frame_processing'].setValue(True)                   #Turn on 'full frame processing'\n  vw\['downrez'].setValue(0)                                    #Set resolution to 1:1\n  nuke.addKnobChanged(viewerKnobChanged, node=vw)              #Inject code in Viewer's knobChanged()\n  vw\['updateUI'].setValue(benchNode\['VIEWER_UPDATEUI'].value())#Inject code in Viewer's updateUI()\n  nuke.root()\['frame'].setValue(sta)                           #Go to first frame\n  clipSize = nukebenchGetClipSize(rd\['file'].value(),sta,end) / 1024 / 1024  #Clip size in MBytes\n  clockStart = time.time()                                     #Store start time in variable\n  nuke.activeViewer().play(1)                                  #Start playback\n                                                               #next steps are picked up by Viewer's knobChanged() script\n                                                               #see viewerKnobChanged() function above\n\ndoReadBenchmark()\n\n  \nnukebenchSetStatus('Ready', '', 'green')" +STARTLINE}
 addUserKnob {22 IO_READ_TO_NULL T "import time\nimport datetime\nimport os\nimport nukescripts\n\n\n\n##############\n#READ IMAGES FROM DISK\n#TIME THE OPERATION\n##############\n\n\ntn        = nuke.thisNode()                      #This Nukebench node\nbp        = tn\['base_path'].value()              #Temp directory\nrzl       = tn\['rez_list'].value().split(',')    #Resolution list\n#sta       = int(tn\['ioFirst'].value())           #Start frame --- DEPRECATED SHOULD BE 1\nsta       = 1                                    #Start frame\nend       = int(tn\['ioLast'].value())            #End frame\nreport    = tn\['IO_REPORT'].value()              #Final report (advanced)\ncomReport = tn\['COM_REPORT'].value()             #Finale report (simple)\nrdl       = tn\['READ_LIST'].value().split(',')   #List of read nodes to test from prefs\n\n#GENERATE REPORT HEADER\nif len(report) > 0:                                                       #If the report is not empty...\n  report += \"\\n\\n\"                                                        #Add 2 new lines\nreport += \"--------------------------------------\"                        #Add separator\nreport += \"\\n\" + datetime.datetime.now().strftime(\"%Y/%m/%d %H:%M:%S\")    #Add date and time\nreport += \"\\n'Read' IO Test\"                                              #Add title line\nreport += '\\n' + str(end-sta+1) + \" frames\"                               #Add number of frames  \n\n\n#CLEAR CACHES\nnukebenchClearCaches()\n\n\n#BUILD THE NODE TREE, RENDER AND TIME\nfor rdn in rdl:                                               #For each Read name in Read List...\n  rd = nuke.toNode(rdn)                                       #Get node object of the Read\n  nukebenchSetStatus('Running IO Read test...', rd.name(), 'orange') #Update status knob\n  wt = nuke.createNode(\"Write\", inpanel=False)                #Create a Write node\n  wt.setInput(0,rd)                                           #Set input to the Read\n  wt.setName(rd.name().replace(\"READ\",\"NULLWRITE\"))           #Set name of the Write\n  wt\['file'].setValue(bp + 'NULLWRITE/NULLWRITE.%04d.null')   #Set path of the write\n  wt\['create_directories'].setValue(0)                        #Dont create dirs\n  wt\['file_type'].setValue(\"null\")                            #Render to the void\n  wt\['xpos'].setValue(rd\['xpos'].value())                     #Set x position in node graph\n  wt\['ypos'].setValue(rd\['ypos'].value()+75)                  #Set y position in node graph\n\n  clockStart = time.time()                                   #Save start time in variable\n  nuke.render(wt,sta,end)                                    #Render Write node from first to last frame\n  clockStop = time.time()                                    #Save end time in variable\n  clockDur = (clockStop-clockStart)                          #Duration of the render in seconds\n  clipLength = (end-sta+1)                                   #Clip length in frames\n  clipSize = nukebenchGetClipSize(rd\['file'].value(),sta,end) / 1024 / 1024  #Clip size in MBytes\n  frameSize = clipSize / clipLength                          #Average frame size in MBytes\n  dataSpeed = clipSize / clockDur                            #Average throughput in MB/s\n  fps = clipLength/clockDur                                  #Average frames per second\n  #Add 1 line to report with all details above\n  report += '\\n' + rd.name() + \",\" + str(round(clockDur,2)) + \" seconds,\" + str(round(clipSize,1)) + \" MBytes,\" + str(round(frameSize,1)) + \" MB/frame,\" + str(round(dataSpeed,2)) + \" MBytes/s,\"+ str(round(fps,2)) + \" fps\"\n  tn\['IO_REPORT'].setValue(report)                           #Write report to IO_REPORT knob\n  \n\n  nuke.delete(wt)                                            #Delete null write node\n\n\nreport += \"\\n--------------------------------------\"         #Add separator\ntn\['IO_REPORT'].setValue(report)\n\nnukebenchSetStatus('Ready', '', 'green')\n             " +STARTLINE}
 addUserKnob {22 CPU_SCANLINE_MULTICARD T "import time\nimport random\nimport datetime\nimport nukescripts\n\n\n##############\n#RENDER 50 CARDS IN SCANLINE RENDER\n#TIME THE OPERATION\n##############\n\n\ntn          = nuke.thisNode()                      #This node (PxF_Nukebench)\nrzl         = tn\['rez_list'].value().split(',')    #Resolution list\nbp          = tn\['base_path'].value()              #Temp directory\nsta         = 1                                    #Start frame\nend         = int(tn\['last'].value())              #End frame\nreport      = tn\['IO_REPORT'].value()              #Report (advanced)\ncomReport   = tn\['COM_REPORT'].value()             #Report (simple)\nuseNew3D    = tn\['useNew3D'].value()               #When true, use 'new' 3D nodes (i.e GeoCard instead of Card, etc...)\nif nuke.NUKE_VERSION_MAJOR <=13:  useNew3D = False #Disable useNew3D if Nuke 13 or below\nnumCards = 50                                      #Number of cards to generate\ncardSize = 0.75                                    #Size of cards to generate\nrandom.seed(9123)                                  #Initialize Python 'random' module\n\n\n#GENERATE REPORT HEADER\nif len(report) > 0:                                                       #If the report is not empty...\n  report += \"\\n\\n\"                                                        #Add 2 new lines   \nreport += \"--------------------------------------\"                        #Add separator\nreport += \"\\n\" + datetime.datetime.now().strftime(\"%Y/%m/%d %H:%M:%S\")    #Add date and time\nif useNew3D:                                                              #If we use new 3D nodes...\n  report += \"\\n'ScanlineRender (New)' CPU Test\"                           #Add 'new' title\nelse:                                                                     #If we use old 3D...\n  report += \"\\n'ScanlineRender (Classic)' CPU Test\"                       #Add 'classic' title\nreport += \"\\n\" + str(end-sta+1) + \" frames\"                               #Add number of frames\ntn\['IO_REPORT'].setValue(report)                                          #Write to IO_REPORT knob\n\n\n#CLEAR CACHES\nnukebenchClearCaches()\n\n\n#FOR EACH TEST RESOLUTION, CREATE THE NODE TREE THEN RENDER AND TIME.\nfor rz in rzl:       \n                         \n  for n in nuke.allNodes():                                    #Delete all nodes except this node.\n    if n is not nuke.thisNode():\n      nuke.delete(n)\n      tn\['READ_LIST'].setValue('')\n  \n  cb1 = nuke.createNode(\"ColorBars\", inpanel=False)            #Create colorbars\n  cb1\['format'].setValue(rz)                                   #Set resolution\n  \n  dt1 = nuke.createNode(\"Expression\", inpanel=False)           #Create an expression node\n  dt1.setInput(0,cb1)                                          #Set input to colorbars\n  dt1\['temp_name0'].setValue('ran')                            #Setup expressions to add noise to image...\n  dt1\['temp_expr0'].setValue('((random(x*y*frame))-0.5)*0.03')\n  dt1\['expr0'].setValue('r+ran')\n  dt1\['expr1'].setValue('g+ran')\n  dt1\['expr2'].setValue('b+ran')\n  dt1\['expr3'].setValue('1')\n  \n#  tx1 = nuke.createNode(\"Text2\", inpanel=False)                #Create text node\n#  tx1.setInput(0,dt1)                                          #Connect input to expression node\n#  tx1\['message'].setValue(rz + \" \[value frame]\")               #Add burn-in text\n#  tx1\['global_font_scale'].setExpression(\"width/2000\")         #Adjust text size to fit frame width\n\n  tx1 = nuke.createNode(\"Text\", inpanel=False)\n  tx1.setInput(0,dt1)                                        #Connect input to noise/colorbars node\n  ft = nukebenchFindFont()\n  if ft:\n    tx1\['font'].setValue(ft)\n  tx1\['message'].setValue(rz + \"\\n\[value frame]\")            #Add burn-in text with format info\n  tx1\['size'].setExpression(\"width/25\")                      #Adjust text size to fit frame width\n  tx1\['xjustify'].setValue(\"center\")                         #Center text\n  tx1\['box'].setValue((0,0,0,0))                             #Set corners to 0,0,0,0\n  tx1\['box'].setExpression('width', 2)                       #Set right side to right edge\n  tx1\['box'].setExpression('height', 3)                      #Set top to top side\n\n\n  \n  mu1 = nuke.createNode(\"Multiply\", inpanel=False)             #Create multiply node\n  mu1.setInput(0,tx1)                                          #Set input to text node\n  mu1\['value'].setValue(0.5)                                   #Set value to 0.5 (50% transparent)\n  \n\n  \n  cdl = \[]                                                     #Initialize card list (to know which nodes to connect to Scene later...)\n  for x in range(0,numCards):                                  #Loop for numCards times...\n    if useNew3D:                                               #If we use new 3D nodes...\n      cd = nuke.nodes.GeoCard()                                #... create a GeoCard\n      cd.setInput(1,mu1)                                       #... connect image input to Multiply\n    else:                                                      #If we use old nodes...\n      cd = nuke.nodes.Card2()                                  #... create a Card\n      cd.setInput(0,mu1)                                       #... connect input to Multiply\n    cd\['translate'].setValue((random.random()*2)-1,0)          #Set X translate to random between -1 and 1\n    cd\['translate'].setValue((random.random()*2)-1,1)          #Set Y translate to random between -1 and 1\n    cd\['rotate'].setExpression('random((frame+' + str(random.randint(0,10000)) + ')/10)*360',2) #Set expression to random Z rotation\n    cd\['scaling'].setValue(cardSize)                           #Scale to cardSize\n    cdl.append(cd)                                             #Append node to card list (for connecting Scene later)\n  \n  if useNew3D:                                                 #If we use new 3D nodes...\n    sc1 = nuke.nodes.GeoScene()                                #... create a GeoScene\n  else:                                                        #If we use old nodes...\n    sc1 = nuke.nodes.Scene()                                   #... create a Scene\n    \n  x = 0                                                        #Iterator\n  for cd in cdl:                                               #For each card in card list...\n    sc1.setInput(x,cd)                                         #... connect a Scene input to the card\n    x += 1                                                     #Increment iterator\n  \n  if useNew3D:                                                 #If we use new 3D nodes...\n    ca1 = nuke.nodes.Camera4()                                 #... create a new style Camera4\n  else:                                                        #If we use old nodes...\n    ca1 = nuke.nodes.Camera2()                                 #... create an old school Camera2\n  ca1\['focal'].setValue(25)                                    #Set focal length to 25mm\n  ca1\['haperture'].setValue(50)                                #Set film back width to 50mm\n  ca1\['vaperture'].setValue(50)                                #Set film back height to 50mm\n  ca1\['translate'].setValue(1,2)                               #Move camera back 1 unit\n  \n  rf1 = nuke.nodes.Reformat()                                  #Create reformat for ScanlineRender BG\n  rf1\['format'].setValue(rz)                                   #Set format to current rez in rez list\n  \n  if useNew3D:                                                 #If we use new 3D nodes...\n    sr1 = nuke.nodes.ScanlineRender2()                         #... create a ScanlineRender2\n  else:                                                        #If we use old nodes...\n    sr1 = nuke.nodes.ScanlineRender()                          #...create a ScanlineRender\n  sr1.setInput(0,rf1)                                          #Set ScanlineRender input0 to Reformat\n  sr1.setInput(1,sc1)                                          #Set ScanlineRender input1 to Scene\n  sr1.setInput(2,ca1)                                          #Set ScanlineRender input2 to Camera\n  \n  \n  wt = nuke.nodes.Write()                                      #Create a Write\n  wt.setInput(0,sr1)                                           #Set input0 to ScanlineRender\n  if useNew3D:                                                 #If we use new 3D nodes...\n    tag = 'SCANLINE_New_'                                      #... set tag to New\n  else:                                                        #If we use old nodes...\n    tag = 'SCANLINE_Classic_'                                  #... set tag to Classic\n  wt.setName(tag + rz)                                         #Set Write node name\n  wt\['file'].setValue(bp + \"/\" + tag + rz + \"/\" + tag + rz + '.%04d.null')  #Set Write file path\n  wt\['file_type'].setValue('null')                             #Set Write file type to 'null' -- dont write to disk\n  wt\['create_directories'].setValue(0)                         #Don't create directory... it's a null!\n  \n  #DO A BIT OF NODE CLEANUP\n  cardsCenter = int((cdl\[-1]\['xpos'].getValue() - cdl\[0]\['xpos'].getValue())/2)\n  mu1\['xpos'].setValue(cardsCenter)\n  mu1\['ypos'].setValue(cdl\[0]\['ypos'].getValue() - 300)\n  nukebenchRepoNode(tx1,mu1,0,-100)\n  nukebenchRepoNode(dt1,tx1,0,-100)\n  nukebenchRepoNode(cb1,dt1,0,-100)\n  sc1\['xpos'].setValue(cardsCenter)\n  nukebenchRepoNode(sc1,sc1,0,300)\n  nukebenchRepoNode(sr1,sc1,0,300)\n  nukebenchRepoNode(ca1,sr1,-200,-100)\n  nukebenchRepoNode(rf1,sr1,+200,-100)\n  nukebenchRepoNode(wt,sr1,0,100)\n  \n      \n  nukebenchSetStatus('Running CPU ScanlineRender test...', wt.name(), 'orange') #Update status knob\n  \n  clockStart = time.time()                                   #Save start time in variable\n  nuke.render(wt,sta,end)                                    #Render Write node from first to last frame\n  clockStop = time.time()                                    #Save end time in variable\n  clockDur = (clockStop-clockStart)                          #Duration of the render in seconds\n  clipLength = (end-sta+1)                                   #Clip length in frames\n  fps = clipLength/clockDur                                  #Average frames per second\n  #Add 1 line to report with all details above\n  report += \"\\n\" + wt.name() + \",\" + str(round(clockDur,2)) + \" seconds,\" + str(round(fps,2)) + \" fps\"\n  tn\['IO_REPORT'].setValue(report)                           #Put report in IO_REPORT knob\n\n  \nreport += \"\\n--------------------------------------\"  #Add separator\ntn\['IO_REPORT'].setValue(report)                      #Dump report in IO_REPORT knob\n\n\n\n\n\n#SET STATUS TO 'READY'\nnukebenchSetStatus('Ready', '', 'green')\n" +STARTLINE}
 addUserKnob {22 GPU_ZDEFOCUS T "import time\nimport datetime\nimport os\nimport nukescripts\n\n\n\n##############\n#DEFOCUS NOISY COLORBARS WITH ZDEFOCUS\n#TIME THE OPERATION\n##############\n\ntn     = nuke.thisNode()                     #This Nukebench node\nuseCPU = tn\['useCPUZDefocus'].value()        #Force CPU render\nbp     = tn\['base_path'].value()             #Base path for temp files\nrzl    = tn\['rez_list'].value().split(',')   #Resolution list\nsta    = 1                                   #Start frame\nend    = int(tn\['last'].value())             #End frame\nreport = tn\['IO_REPORT'].value()             #Final report\n\n#GENERATE REPORT HEADER\nif len(report) > 0:                                                      #If the report is not empty...\n  report += \"\\n\\n\"                                                       #Add 2 new lines\nreport += \"--------------------------------------\"                       #Add separator\nreport += \"\\n\" + datetime.datetime.now().strftime(\"%Y/%m/%d %H:%M:%S\")   #Add date and time\nif useCPU:\n  report += \"\\n'ZDefocus' CPU Test\"                                       #Add title line\nelse:\n  report += \"\\n'ZDefocus' GPU Test\"\nreport += \"\\n\" + str(end-sta+1) + \" frames\"                              #Add number of frames\ntn\['IO_REPORT'].setValue(report)                                         #Write report to IO_REPORT knob\n\n#CLEAR CACHES\nnukebenchClearCaches()\n\n#MAIN LOOP - BUILD NODE TREE, RENDER AND TIME\nfor rz in rzl:\n  \n  #Before we build our tree, delete all nodes.\n  for n in nuke.allNodes():                 \n    if n is not nuke.thisNode():\n      nuke.delete(n)                        \n      tn\['READ_LIST'].setValue('')\n \n  cb1 = nuke.createNode(\"ColorBars\", inpanel=False)            #Create colorbars\n  cb1\['format'].setValue(rz)                                   #Set resolution\n  \n  dt1 = nuke.createNode(\"Expression\", inpanel=False)           #Create an expression node\n  dt1.setInput(0,cb1)                                          #Set input to colorbars\n  dt1\['temp_name0'].setValue('ran')                            #Setup expressions to add noise to image...\n  dt1\['temp_expr0'].setValue('((random(x*y*frame))-0.5)*0.03')\n  dt1\['expr0'].setValue('r+ran')\n  dt1\['expr1'].setValue('g+ran')\n  dt1\['expr2'].setValue('b+ran')\n  dt1\['expr3'].setValue('1')\n  \n#  tx1 = nuke.createNode(\"Text2\", inpanel=False)                #Create text node\n#  tx1.setInput(0,dt1)                                          #Connect input to expression node\n#  tx1\['message'].setValue(rz + \" \[value frame]\")               #Add burn-in text\n#  tx1\['global_font_scale'].setExpression(\"width/2000\")         #Adjust text size to fit frame width\n#  \n  tx1 = nuke.createNode(\"Text\", inpanel=False)               #Create old school text node\n  tx1.setInput(0,dt1)                                        #Connect input to noise/colorbars node\n  ft = nukebenchFindFont()                                   #Get pref font path (Arial, Helvetica, Utopia, Courier)\n  if ft:                                                     #If we found a valid font path...\n    tx1\['font'].setValue(ft)                                 #... set the font knob\n  tx1\['message'].setValue(rz + \"\\n\[value frame]\")            #Add burn-in text with format info\n  tx1\['size'].setExpression(\"width/25\")                      #Adjust text size to fit frame width\n  tx1\['xjustify'].setValue(\"center\")                         #Center text\n  tx1\['box'].setValue((0,0,0,0))                             #Set corners to 0,0,0,0\n  tx1\['box'].setExpression('width', 2)                       #Set right side to right edge\n  tx1\['box'].setExpression('height', 3)                      #Set top to top side\n\n   \n  rp1 = nuke.createNode(\"Ramp\", inpanel=False)                 #Create ramp node to drive defocus\n  rp1.setInput(0,tx1)                                          #Set input to text node\n  rp1\['output'].setValue('depth')                              #Output to depth.Z layer\n  rp1\['p0'].setValue(0,0)                                      #Point 0 = bottom left\n  rp1\['p0'].setValue(0,1)\n  rp1\['p1'].setExpression(\"width\",0)                           #Point 1 = top right\n  rp1\['p1'].setExpression(\"height\",1)\n  \n  df1 = nuke.createNode(\"ZDefocus2\", inpanel=False)            #Create ZDefocus\n  df1.setInput(0,rp1)                                          #Connect to ramp\n  if useCPU:\n    df1\['useGPUIfAvailable'].setValue(0)\n  else:\n    df1\['useGPUIfAvailable'].setValue(1)\n  df1\['math'].setValue('direct')                               #Set knobs to make pretty defocus...\n  df1\['size'].setExpression(\"width/50\")\n  df1\['max_size'].setExpression(\"size\")\n\n  wt = nuke.createNode(\"Write\", inpanel=False)                                  #Create write node\n  wt.setInput(0,df1)                                                            #Set input to ZDefocus\n  wt.setName(\"ZDEFOCUS_\" + rz)                                                  #Name the node\n  wt\['file'].setValue(bp + 'ZDEFOCUS_' + rz + '/ZDEFOCUS_' + rz + '.%04d.null') #Set file path\n  wt\['create_directories'].setValue(0)                                          #Dont create directories... it's a null write!\n  wt\['file_type'].setValue(\"null\")                                              #Render to the void...\n  \n\n  #CLEAN NODE GRAPH\n  nuke.selectAll()          #Select all nodes\n  nuke.autoplace_all()      #Autoplace (like hotkey L)\n  \n  \n  #RENDER AND TIME, LOG RESULTS IN REPORT\n  nukebenchSetStatus('Running GPU ZDefocus test...', wt.name(), 'orange')  #Update status knob\n  clockStart = time.time()                                                 #Save start time in variable\n  nuke.render(wt,sta,end)                                                  #Render Write node from first to last frame\n  clockStop = time.time()                                                  #Save end time in variable\n  clockDur = (clockStop-clockStart)                                        #Duration of the render in seconds\n  clipLength = (end-sta+1)                                                 #Clip length in frames\n  fps = clipLength/clockDur                                                #Average frames per second\n  #Add 1 line to report with all details above\n  report += \"\\n\" + wt.name() + \",\" + str(round(clockDur,2)) + \" seconds,\" + str(round(fps,2)) + \" fps\"\n  tn\['IO_REPORT'].setValue(report)                                         #Write report to IO_REPORT knob\n  \n\nreport = report + \"\\n--------------------------------------\"               #Add separator\ntn\['IO_REPORT'].setValue(report)                                           #Write report to IO_REPORT knob\n\nnukebenchSetStatus('Ready', '', 'green')\n             " +STARTLINE}
 addUserKnob {22 GPU_INFERENCE T "import time\nimport datetime\nimport os\nimport nukescripts\n\n\n##############\n#APPLY INFERENCE NODE TO NOISE\n#TIME THE OPERATION\n##############\n\n\ndef runGPUtest():\n  \n  tn        = nuke.thisNode()                                                                  #This Nukebench node\n  useCPU    = tn\['useCPUInference'].value()                                                    #Force CPU render\n  bp        = tn\['base_path'].value()                                                          #Temp directory\n  cf        = os.path.abspath(os.path.expanduser(tn\['catFile'].value())).replace('\\\\','/')     #Path for inference cat file\n  rzl       = tn\['rez_list'].value().split(',')                                                #Resolution list\n  sta       = 1                                                                                #Start frame  --- DEPRECATED SHOULD BE 1\n  end       = int(tn\['last'].value())                                                          #End frame\n  scl       = tn\['inferenceScale'].value()                                                     #Scale ratio (string) (to lower rez for faster test)\n  fscl      = 1.0 / float(scl.split(':')\[1])                                                   #Scale ratio (float)\n  report    = tn\['IO_REPORT'].value()                                                          #Report \n  \n\n\n  #GENERATE REPORT HEADER\n  if len(report) > 0:                                                        #If the report is not empty...\n    report += \"\\n\\n\"                                                         #Add a new line\n  report += \"--------------------------------------\"                         #Add separator\n  report += \"\\n\" + datetime.datetime.now().strftime(\"%Y/%m/%d %H:%M:%S\")     #Add date and time\n  if useCPU:\n    report += \"\\n'Inference' CPU Test\"\n  else:\n    report += \"\\n'Inference' GPU Test\"                                         \n  report += '\\n' + str(end-sta+1) + \" frames\"                                #Duration\n  tn\['IO_REPORT'].setValue(report)                                           #Write report to IO_REPORT knob\n  \n  #CLEAR CACHES\n  nukebenchClearCaches()\n\n  #FOR EACH TEST RESOLUTION, CREATE NODE TREE, RENDER AND TIME THE RESULT\n  for rz in rzl:                                               \n    #BEFORE BUILDING OUR TREE, DELETE ALL NODES\n    for n in nuke.allNodes():                      \n      if n is not nuke.thisNode():\n        tn\['READ_LIST'].setValue('')                           \n        nuke.delete(n)                                         \n\n    rf1 = nuke.nodes.Reformat()                                #Create reformat\n    rf1\['type'].setValue(\"to format\")                          #Set type to 'to format'\n    rf1\['format'].setValue(rz)                                 #Set resolution\n    \n    rf2 = nuke.nodes.Reformat()                                #Create 2nd reformat\n    rf2.setInput(0,rf1)                                        #Set input to 1st reformat\n    rf2\['type'].setValue('scale')                              #Set to scale mode\n    rf2\['scale'].setValue(fscl)                                #Set scale to scale ratio from prefs\n    \n    ns1 = nuke.createNode('Noise', inpanel=False)              #Create noise node\n    ns1.setInput(0,rf2)                                        #Connect to 2nd reformat\n    ns1\['size'].setExpression('width/4')                       #Adjust noise size\n    ns1\['zoffset'].setExpression('frame/10')                   #Animate noise\n  \n#    tx1 = nuke.createNode(\"Text2\", inpanel=False)              #Create text node\n#    tx1.setInput(0,ns1)                                        #Connect input to noise node\n#    tx1\['message'].setValue(rz + \" \[value frame]\")             #Add burn-in text\n#    tx1\['global_font_scale'].setExpression(\"width/2000\")       #Adjust text size to fit frame width\n#\n    tx1 = nuke.createNode(\"Text\", inpanel=False)               #Create old school text node\n    tx1.setInput(0,ns1)                                        #Connect input to noise/colorbars node\n    ft = nukebenchFindFont()                                   #Get pref font path (Arial, Helvetica, Utopia, Courier)\n    if ft:                                                     #If we found a valid font path...\n      tx1\['font'].setValue(ft)                                 #... set the font knob\n    tx1\['message'].setValue(rz + \"\\n\[value frame]\")            #Add burn-in text with format info\n    tx1\['size'].setExpression(\"width/25\")                      #Adjust text size to fit frame width\n    tx1\['xjustify'].setValue(\"center\")                         #Center text\n    tx1\['box'].setValue((0,0,0,0))                             #Set corners to 0,0,0,0\n    tx1\['box'].setExpression('width', 2)                       #Set right side to right edge\n    tx1\['box'].setExpression('height', 3)                      #Set top to top side\n\n\n\n    \n    cp1 = nuke.createNode(\"Colorspace\", inpanel=False)        #Create colorspace node \n    cp1.setInput(0,tx1)                                       #Connect to text node\n    cp1\['colorspace_out'].setValue('sRGB')                    #Set output to sRGB (lin2sRGB) (Cattery files expect sRGB pixels)\n    \n    in1 = nuke.createNode(\"Inference\", inpanel=False)         #Create inference node\n    in1\['modelFile'].setValue(cf)                             #Use cat file from prefs\n    in1\['halfPrecision'].setValue(1)                          #Set to 16 bit processing\n    if useCPU:                                                #If use CPU switch is ON...\n      in1\['useGPUIfAvailable'].setValue(0)                    #...turn off GPU mode\n    else:                                                     #If use CPU swith is OFF...\n      in1\['useGPUIfAvailable'].setValue(1)                    #... turn on GPU mode\n    in1.setInput(0,cp1)                                       #Connect to Colorspace node\n  \n    cp2 = nuke.createNode(\"Colorspace\", inpanel=False)        #Create colorspace node  \n    cp2.setInput(0,in1)                                       #Set input to inference node\n    cp2\['colorspace_in'].setValue('sRGB')                     #Set input to sRGB (sRGB2lin)\n  \n    wt = nuke.createNode(\"Write\", inpanel=False)              #Create write node\n    wt.setInput(0,cp2)                                        #Set input to colorspace\n    wt.setName(\"INFERENCE_\" + rz)                             #Name the write node\n    wt\['file'].setValue(bp + 'INFERENCE_' + rz + '/INFERENCE_' + rz + '.%04d.null')  #Set file path\n    wt\['create_directories'].setValue(0)                      #Create directories off\n    wt\['file_type'].setValue(\"null\")                          #Render to the void\n    \n    #CLEAN NODE GRAPH\n    nuke.selectAll()          #Select all nodes\n    nuke.autoplace_all()      #Autoplace (like hotkey L)\n    \n  \n    #RENDER AND TIME WRITE NODE, LOG RESULTS IN REPORT\n    nukebenchSetStatus('Running GPU Inference test...', wt.name() + ' @ ' + scl, 'orange')\n    clockStart = time.time()                                   #Save start time in variable\n    nuke.render(wt,sta,end)                                    #Render Write node from first to last frame\n    clockStop = time.time()                                    #Save end time in variable\n    clockDur = (clockStop-clockStart)                          #Duration of the render in seconds\n    clipLength = (end-sta+1)                                   #Clip length in frames\n    fps = clipLength/clockDur                                  #Average frames per second\n    #Add 1 line to report with all details above\n    report += '\\n' + wt.name() + '@' + scl + \",\" + str(round(clockDur,2)) + \" seconds,\" + str(round(fps,2)) + \" fps\"\n    tn\['IO_REPORT'].setValue(report)                           #Write report to IO_REPORT knob\n    \n  \n\n  report = report + \"\\n--------------------------------------\" #Add separator\n  tn\['IO_REPORT'].setValue(report)                             #Write report to IO_REPORT knob\n\n#### RUN MAIN FUNCTION ####\nrunGPUtest()\nnukebenchSetStatus('Ready', '', 'green')" +STARTLINE}
 addUserKnob {22 VIEWER_UPDATEUI T "import time\n\nglobal end\nglobal sta\nglobal report\nglobal benchNode\nglobal rdl\nglobal rdlidx\nglobal clipSize\n\ntn = nuke.thisNode()                                         #This node (Viewer)\nif tn\['frame'].value() == end:                               #If we are at the last frame...\n  clockStop = time.time()                                    #Save end time in variable\n  clockDur = (clockStop-clockStart)                          #Duration of the render in seconds\n  clipLength = (end-sta+1)                                   #Clip length in frames\n  frameSize = clipSize / clipLength                          #Average frame size in MBytes\n  dataSpeed = clipSize / clockDur                            #Average throughput in MB/s\n  fps = clipLength/clockDur                                  #Average frames per second\n  #Add 1 line to report with all details above\n  report += \"\\n\" + nuke.toNode(rdl\[rdlidx]).name() + \",\" + str(round(clockDur,2)) + \" seconds,\" + str(round(clipSize,1)) + \" MBytes,\" + str(round(frameSize,1)) + \" MB/frame,\" + str(round(dataSpeed,2)) + \" MBytes/s,\"+ str(round(fps,2)) + \" fps\"\n  benchNode\['IO_REPORT'].setValue(report)                    #Write report to IO_REPORT knob\n  rdlidx = rdlidx + 1                                        #Increment rdlidx so READ_IO will know to go to next Read in the list\n  benchNode\[\"IO_READ_TO_VIEWER\"].execute()                   #Trigger READ_IO button to launch next loop\n  \n  \n  \n" +STARTLINE}
 addUserKnob {22 inject_nodes T "import nuke\nimport zlib\nimport base64\nfrom PySide2 import QtWidgets\n\n\ntn = nuke.thisNode()\ntn\['INIT_FUNCTIONS'].execute()\nnuke.nodeCopy('%clipboard%')\nbestFont = nukebenchFindFont()\nclip = QtWidgets.QApplication.clipboard().text()\nclip = clip.replace(tn.name(), \"NUKEBENCHNAME\")\nclip = clip.replace(bestFont, 'NUKEBENCHFONT')\nzclip = zlib.compress(clip.encode())\nbclip = base64.b64encode(zclip).decode('utf-8')\ntn\['node_graph'].setValue(bclip)\n" +STARTLINE}
 addUserKnob {22 eject_nodes -STARTLINE T "import nuke\nimport zlib\nimport base64\nfrom PySide2 import QtWidgets\n\n\ntn = nuke.thisNode()\ntnName = tn.name()\ntn\['INIT_FUNCTIONS'].execute()\nbestFont = nukebenchFindFont().replace(' ', '\\\\ ')\nbclip = tn\['node_graph'].getValue()\nzclip = base64.b64decode(bclip)\nclip = zlib.decompress(zclip).decode('utf-8')\nclip = clip.replace('NUKEBENCHNAME', tnName)\nclip = clip.replace('NUKEBENCHFONT', bestFont)\nQtWidgets.QApplication.clipboard().setText(clip)\nnuke.nodePaste(\"%clipboard%\")\n"}
 addUserKnob {1 node_graph}
 node_graph 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
}
